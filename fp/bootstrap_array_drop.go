// bootstrap_array_drop.go
// DO NOT EDIT THIS FILE WAS GENERATED AUTOMATICALLY BY https://github.com/zx80live/gofp-bootstrap

package fp

func BoolArrayDrop(m []bool, i int) []bool {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]bool, 0)
	}
}
func StringArrayDrop(m []string, i int) []string {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]string, 0)
	}
}
func IntArrayDrop(m []int, i int) []int {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]int, 0)
	}
}
func Int8ArrayDrop(m []int8, i int) []int8 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]int8, 0)
	}
}
func Int16ArrayDrop(m []int16, i int) []int16 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]int16, 0)
	}
}
func Int32ArrayDrop(m []int32, i int) []int32 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]int32, 0)
	}
}
func Int64ArrayDrop(m []int64, i int) []int64 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]int64, 0)
	}
}
func UintArrayDrop(m []uint, i int) []uint {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]uint, 0)
	}
}
func Uint8ArrayDrop(m []uint8, i int) []uint8 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]uint8, 0)
	}
}
func Uint16ArrayDrop(m []uint16, i int) []uint16 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]uint16, 0)
	}
}
func Uint32ArrayDrop(m []uint32, i int) []uint32 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]uint32, 0)
	}
}
func Uint64ArrayDrop(m []uint64, i int) []uint64 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]uint64, 0)
	}
}
func UintptrArrayDrop(m []uintptr, i int) []uintptr {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]uintptr, 0)
	}
}
func ByteArrayDrop(m []byte, i int) []byte {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]byte, 0)
	}
}
func RuneArrayDrop(m []rune, i int) []rune {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]rune, 0)
	}
}
func Float32ArrayDrop(m []float32, i int) []float32 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]float32, 0)
	}
}
func Float64ArrayDrop(m []float64, i int) []float64 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]float64, 0)
	}
}
func Complex64ArrayDrop(m []complex64, i int) []complex64 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]complex64, 0)
	}
}
func Complex128ArrayDrop(m []complex128, i int) []complex128 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]complex128, 0)
	}
}
func AnyArrayDrop(m []Any, i int) []Any {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Any, 0)
	}
}
func BoolArrayArrayDrop(m [][]bool, i int) [][]bool {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]bool, 0)
	}
}
func StringArrayArrayDrop(m [][]string, i int) [][]string {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]string, 0)
	}
}
func IntArrayArrayDrop(m [][]int, i int) [][]int {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]int, 0)
	}
}
func Int8ArrayArrayDrop(m [][]int8, i int) [][]int8 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]int8, 0)
	}
}
func Int16ArrayArrayDrop(m [][]int16, i int) [][]int16 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]int16, 0)
	}
}
func Int32ArrayArrayDrop(m [][]int32, i int) [][]int32 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]int32, 0)
	}
}
func Int64ArrayArrayDrop(m [][]int64, i int) [][]int64 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]int64, 0)
	}
}
func UintArrayArrayDrop(m [][]uint, i int) [][]uint {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]uint, 0)
	}
}
func Uint8ArrayArrayDrop(m [][]uint8, i int) [][]uint8 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]uint8, 0)
	}
}
func Uint16ArrayArrayDrop(m [][]uint16, i int) [][]uint16 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]uint16, 0)
	}
}
func Uint32ArrayArrayDrop(m [][]uint32, i int) [][]uint32 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]uint32, 0)
	}
}
func Uint64ArrayArrayDrop(m [][]uint64, i int) [][]uint64 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]uint64, 0)
	}
}
func UintptrArrayArrayDrop(m [][]uintptr, i int) [][]uintptr {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]uintptr, 0)
	}
}
func ByteArrayArrayDrop(m [][]byte, i int) [][]byte {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]byte, 0)
	}
}
func RuneArrayArrayDrop(m [][]rune, i int) [][]rune {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]rune, 0)
	}
}
func Float32ArrayArrayDrop(m [][]float32, i int) [][]float32 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]float32, 0)
	}
}
func Float64ArrayArrayDrop(m [][]float64, i int) [][]float64 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]float64, 0)
	}
}
func Complex64ArrayArrayDrop(m [][]complex64, i int) [][]complex64 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]complex64, 0)
	}
}
func Complex128ArrayArrayDrop(m [][]complex128, i int) [][]complex128 {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]complex128, 0)
	}
}
func AnyArrayArrayDrop(m [][]Any, i int) [][]Any {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([][]Any, 0)
	}
}
func BoolOptionArrayDrop(m []BoolOption, i int) []BoolOption {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]BoolOption, 0)
	}
}
func StringOptionArrayDrop(m []StringOption, i int) []StringOption {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]StringOption, 0)
	}
}
func IntOptionArrayDrop(m []IntOption, i int) []IntOption {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]IntOption, 0)
	}
}
func Int8OptionArrayDrop(m []Int8Option, i int) []Int8Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Int8Option, 0)
	}
}
func Int16OptionArrayDrop(m []Int16Option, i int) []Int16Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Int16Option, 0)
	}
}
func Int32OptionArrayDrop(m []Int32Option, i int) []Int32Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Int32Option, 0)
	}
}
func Int64OptionArrayDrop(m []Int64Option, i int) []Int64Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Int64Option, 0)
	}
}
func UintOptionArrayDrop(m []UintOption, i int) []UintOption {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]UintOption, 0)
	}
}
func Uint8OptionArrayDrop(m []Uint8Option, i int) []Uint8Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Uint8Option, 0)
	}
}
func Uint16OptionArrayDrop(m []Uint16Option, i int) []Uint16Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Uint16Option, 0)
	}
}
func Uint32OptionArrayDrop(m []Uint32Option, i int) []Uint32Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Uint32Option, 0)
	}
}
func Uint64OptionArrayDrop(m []Uint64Option, i int) []Uint64Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Uint64Option, 0)
	}
}
func UintptrOptionArrayDrop(m []UintptrOption, i int) []UintptrOption {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]UintptrOption, 0)
	}
}
func ByteOptionArrayDrop(m []ByteOption, i int) []ByteOption {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]ByteOption, 0)
	}
}
func RuneOptionArrayDrop(m []RuneOption, i int) []RuneOption {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]RuneOption, 0)
	}
}
func Float32OptionArrayDrop(m []Float32Option, i int) []Float32Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Float32Option, 0)
	}
}
func Float64OptionArrayDrop(m []Float64Option, i int) []Float64Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Float64Option, 0)
	}
}
func Complex64OptionArrayDrop(m []Complex64Option, i int) []Complex64Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Complex64Option, 0)
	}
}
func Complex128OptionArrayDrop(m []Complex128Option, i int) []Complex128Option {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]Complex128Option, 0)
	}
}
func AnyOptionArrayDrop(m []AnyOption, i int) []AnyOption {
	s := len(m)
	if i < 0 || i >= s {
		panic("index out of bound")
	}
	if s > 0 {
		return m[i : s-1]
	} else {
		return make([]AnyOption, 0)
	}
}
