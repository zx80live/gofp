// bootstrap_array_zip.go
// DO NOT EDIT THIS FILE WAS GENERATED AUTOMATICALLY BY https://github.com/zx80live/gofp-bootstrap

package fp


func (a BoolArray) ZipBoolArray(a2 BoolArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a BoolArray) ZipStringArray(a2 StringArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a BoolArray) ZipIntArray(a2 IntArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a BoolArray) ZipInt64Array(a2 Int64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a BoolArray) ZipByteArray(a2 ByteArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a BoolArray) ZipRuneArray(a2 RuneArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a BoolArray) ZipFloat32Array(a2 Float32Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a BoolArray) ZipFloat64Array(a2 Float64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a BoolArray) ZipAnyArray(a2 AnyArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a BoolArray) ZipTuple2Array(a2 Tuple2Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a BoolArray) ZipBoolList(l2 BoolList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a BoolArray) ZipStringList(l2 StringList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a BoolArray) ZipIntList(l2 IntList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a BoolArray) ZipInt64List(l2 Int64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a BoolArray) ZipByteList(l2 ByteList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a BoolArray) ZipRuneList(l2 RuneList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a BoolArray) ZipFloat32List(l2 Float32List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a BoolArray) ZipFloat64List(l2 Float64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a BoolArray) ZipAnyList(l2 AnyList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a BoolArray) ZipTuple2List(l2 Tuple2List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a StringArray) ZipBoolArray(a2 BoolArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a StringArray) ZipStringArray(a2 StringArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a StringArray) ZipIntArray(a2 IntArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a StringArray) ZipInt64Array(a2 Int64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a StringArray) ZipByteArray(a2 ByteArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a StringArray) ZipRuneArray(a2 RuneArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a StringArray) ZipFloat32Array(a2 Float32Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a StringArray) ZipFloat64Array(a2 Float64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a StringArray) ZipAnyArray(a2 AnyArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a StringArray) ZipTuple2Array(a2 Tuple2Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a StringArray) ZipBoolList(l2 BoolList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a StringArray) ZipStringList(l2 StringList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a StringArray) ZipIntList(l2 IntList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a StringArray) ZipInt64List(l2 Int64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a StringArray) ZipByteList(l2 ByteList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a StringArray) ZipRuneList(l2 RuneList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a StringArray) ZipFloat32List(l2 Float32List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a StringArray) ZipFloat64List(l2 Float64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a StringArray) ZipAnyList(l2 AnyList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a StringArray) ZipTuple2List(l2 Tuple2List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a IntArray) ZipBoolArray(a2 BoolArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a IntArray) ZipStringArray(a2 StringArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a IntArray) ZipIntArray(a2 IntArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a IntArray) ZipInt64Array(a2 Int64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a IntArray) ZipByteArray(a2 ByteArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a IntArray) ZipRuneArray(a2 RuneArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a IntArray) ZipFloat32Array(a2 Float32Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a IntArray) ZipFloat64Array(a2 Float64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a IntArray) ZipAnyArray(a2 AnyArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a IntArray) ZipTuple2Array(a2 Tuple2Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a IntArray) ZipBoolList(l2 BoolList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a IntArray) ZipStringList(l2 StringList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a IntArray) ZipIntList(l2 IntList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a IntArray) ZipInt64List(l2 Int64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a IntArray) ZipByteList(l2 ByteList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a IntArray) ZipRuneList(l2 RuneList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a IntArray) ZipFloat32List(l2 Float32List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a IntArray) ZipFloat64List(l2 Float64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a IntArray) ZipAnyList(l2 AnyList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a IntArray) ZipTuple2List(l2 Tuple2List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Int64Array) ZipBoolArray(a2 BoolArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Int64Array) ZipStringArray(a2 StringArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Int64Array) ZipIntArray(a2 IntArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Int64Array) ZipInt64Array(a2 Int64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Int64Array) ZipByteArray(a2 ByteArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Int64Array) ZipRuneArray(a2 RuneArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Int64Array) ZipFloat32Array(a2 Float32Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Int64Array) ZipFloat64Array(a2 Float64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Int64Array) ZipAnyArray(a2 AnyArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Int64Array) ZipTuple2Array(a2 Tuple2Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Int64Array) ZipBoolList(l2 BoolList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Int64Array) ZipStringList(l2 StringList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Int64Array) ZipIntList(l2 IntList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Int64Array) ZipInt64List(l2 Int64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Int64Array) ZipByteList(l2 ByteList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Int64Array) ZipRuneList(l2 RuneList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Int64Array) ZipFloat32List(l2 Float32List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Int64Array) ZipFloat64List(l2 Float64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Int64Array) ZipAnyList(l2 AnyList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Int64Array) ZipTuple2List(l2 Tuple2List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a ByteArray) ZipBoolArray(a2 BoolArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a ByteArray) ZipStringArray(a2 StringArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a ByteArray) ZipIntArray(a2 IntArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a ByteArray) ZipInt64Array(a2 Int64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a ByteArray) ZipByteArray(a2 ByteArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a ByteArray) ZipRuneArray(a2 RuneArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a ByteArray) ZipFloat32Array(a2 Float32Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a ByteArray) ZipFloat64Array(a2 Float64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a ByteArray) ZipAnyArray(a2 AnyArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a ByteArray) ZipTuple2Array(a2 Tuple2Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a ByteArray) ZipBoolList(l2 BoolList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a ByteArray) ZipStringList(l2 StringList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a ByteArray) ZipIntList(l2 IntList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a ByteArray) ZipInt64List(l2 Int64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a ByteArray) ZipByteList(l2 ByteList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a ByteArray) ZipRuneList(l2 RuneList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a ByteArray) ZipFloat32List(l2 Float32List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a ByteArray) ZipFloat64List(l2 Float64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a ByteArray) ZipAnyList(l2 AnyList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a ByteArray) ZipTuple2List(l2 Tuple2List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a RuneArray) ZipBoolArray(a2 BoolArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a RuneArray) ZipStringArray(a2 StringArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a RuneArray) ZipIntArray(a2 IntArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a RuneArray) ZipInt64Array(a2 Int64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a RuneArray) ZipByteArray(a2 ByteArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a RuneArray) ZipRuneArray(a2 RuneArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a RuneArray) ZipFloat32Array(a2 Float32Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a RuneArray) ZipFloat64Array(a2 Float64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a RuneArray) ZipAnyArray(a2 AnyArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a RuneArray) ZipTuple2Array(a2 Tuple2Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a RuneArray) ZipBoolList(l2 BoolList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a RuneArray) ZipStringList(l2 StringList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a RuneArray) ZipIntList(l2 IntList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a RuneArray) ZipInt64List(l2 Int64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a RuneArray) ZipByteList(l2 ByteList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a RuneArray) ZipRuneList(l2 RuneList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a RuneArray) ZipFloat32List(l2 Float32List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a RuneArray) ZipFloat64List(l2 Float64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a RuneArray) ZipAnyList(l2 AnyList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a RuneArray) ZipTuple2List(l2 Tuple2List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float32Array) ZipBoolArray(a2 BoolArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float32Array) ZipStringArray(a2 StringArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float32Array) ZipIntArray(a2 IntArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float32Array) ZipInt64Array(a2 Int64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float32Array) ZipByteArray(a2 ByteArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float32Array) ZipRuneArray(a2 RuneArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float32Array) ZipFloat32Array(a2 Float32Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float32Array) ZipFloat64Array(a2 Float64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float32Array) ZipAnyArray(a2 AnyArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float32Array) ZipTuple2Array(a2 Tuple2Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float32Array) ZipBoolList(l2 BoolList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float32Array) ZipStringList(l2 StringList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float32Array) ZipIntList(l2 IntList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float32Array) ZipInt64List(l2 Int64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float32Array) ZipByteList(l2 ByteList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float32Array) ZipRuneList(l2 RuneList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float32Array) ZipFloat32List(l2 Float32List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float32Array) ZipFloat64List(l2 Float64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float32Array) ZipAnyList(l2 AnyList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float32Array) ZipTuple2List(l2 Tuple2List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float64Array) ZipBoolArray(a2 BoolArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float64Array) ZipStringArray(a2 StringArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float64Array) ZipIntArray(a2 IntArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float64Array) ZipInt64Array(a2 Int64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float64Array) ZipByteArray(a2 ByteArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float64Array) ZipRuneArray(a2 RuneArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float64Array) ZipFloat32Array(a2 Float32Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float64Array) ZipFloat64Array(a2 Float64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float64Array) ZipAnyArray(a2 AnyArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float64Array) ZipTuple2Array(a2 Tuple2Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Float64Array) ZipBoolList(l2 BoolList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float64Array) ZipStringList(l2 StringList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float64Array) ZipIntList(l2 IntList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float64Array) ZipInt64List(l2 Int64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float64Array) ZipByteList(l2 ByteList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float64Array) ZipRuneList(l2 RuneList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float64Array) ZipFloat32List(l2 Float32List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float64Array) ZipFloat64List(l2 Float64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float64Array) ZipAnyList(l2 AnyList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Float64Array) ZipTuple2List(l2 Tuple2List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a AnyArray) ZipBoolArray(a2 BoolArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a AnyArray) ZipStringArray(a2 StringArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a AnyArray) ZipIntArray(a2 IntArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a AnyArray) ZipInt64Array(a2 Int64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a AnyArray) ZipByteArray(a2 ByteArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a AnyArray) ZipRuneArray(a2 RuneArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a AnyArray) ZipFloat32Array(a2 Float32Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a AnyArray) ZipFloat64Array(a2 Float64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a AnyArray) ZipAnyArray(a2 AnyArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a AnyArray) ZipTuple2Array(a2 Tuple2Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a AnyArray) ZipBoolList(l2 BoolList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a AnyArray) ZipStringList(l2 StringList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a AnyArray) ZipIntList(l2 IntList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a AnyArray) ZipInt64List(l2 Int64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a AnyArray) ZipByteList(l2 ByteList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a AnyArray) ZipRuneList(l2 RuneList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a AnyArray) ZipFloat32List(l2 Float32List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a AnyArray) ZipFloat64List(l2 Float64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a AnyArray) ZipAnyList(l2 AnyList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a AnyArray) ZipTuple2List(l2 Tuple2List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Tuple2Array) ZipBoolArray(a2 BoolArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Tuple2Array) ZipStringArray(a2 StringArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Tuple2Array) ZipIntArray(a2 IntArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Tuple2Array) ZipInt64Array(a2 Int64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Tuple2Array) ZipByteArray(a2 ByteArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Tuple2Array) ZipRuneArray(a2 RuneArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Tuple2Array) ZipFloat32Array(a2 Float32Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Tuple2Array) ZipFloat64Array(a2 Float64Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Tuple2Array) ZipAnyArray(a2 AnyArray) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Tuple2Array) ZipTuple2Array(a2 Tuple2Array) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(len(a2))))
  zipped := make([]Tuple2, minLen)
  for i := 0; i < minLen; i++ {
    zipped[i] = Tuple2 { a[i], a2[i] }
  }
  return zipped
}
func (a Tuple2Array) ZipBoolList(l2 BoolList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Tuple2Array) ZipStringList(l2 StringList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Tuple2Array) ZipIntList(l2 IntList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Tuple2Array) ZipInt64List(l2 Int64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Tuple2Array) ZipByteList(l2 ByteList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Tuple2Array) ZipRuneList(l2 RuneList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Tuple2Array) ZipFloat32List(l2 Float32List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Tuple2Array) ZipFloat64List(l2 Float64List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Tuple2Array) ZipAnyList(l2 AnyList) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}
func (a Tuple2Array) ZipTuple2List(l2 Tuple2List) Tuple2Array {
  minLen := int(Int(len(a)).Min(Int(l2.Size())))
  zipped := make([]Tuple2, minLen)
  xs := l2
  for i := 0; xs.NonEmpty() && i < minLen; i ++ {
    zipped[i] = Tuple2 { a[i], *xs.head }
    xs = *xs.tail
  }
  return zipped
}