// bootstrap_array_zipall.go
// DO NOT EDIT THIS FILE WAS GENERATED AUTOMATICALLY BY https://github.com/zx80live/gofp-bootstrap

package fp


func (a BoolArray) ZipAllBoolArray(a2 BoolArray, thisDefault Bool, thatDefault Bool) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllStringArray(a2 StringArray, thisDefault Bool, thatDefault String) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllIntArray(a2 IntArray, thisDefault Bool, thatDefault Int) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllInt64Array(a2 Int64Array, thisDefault Bool, thatDefault Int64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllByteArray(a2 ByteArray, thisDefault Bool, thatDefault Byte) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllRuneArray(a2 RuneArray, thisDefault Bool, thatDefault Rune) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllFloat32Array(a2 Float32Array, thisDefault Bool, thatDefault Float32) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllFloat64Array(a2 Float64Array, thisDefault Bool, thatDefault Float64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllAnyArray(a2 AnyArray, thisDefault Bool, thatDefault Any) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllTuple2Array(a2 Tuple2Array, thisDefault Bool, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllBoolList(l2 BoolList, thisDefault Bool, thatDefault Bool) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllStringList(l2 StringList, thisDefault Bool, thatDefault String) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllIntList(l2 IntList, thisDefault Bool, thatDefault Int) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllInt64List(l2 Int64List, thisDefault Bool, thatDefault Int64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllByteList(l2 ByteList, thisDefault Bool, thatDefault Byte) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllRuneList(l2 RuneList, thisDefault Bool, thatDefault Rune) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllFloat32List(l2 Float32List, thisDefault Bool, thatDefault Float32) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllFloat64List(l2 Float64List, thisDefault Bool, thatDefault Float64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllAnyList(l2 AnyList, thisDefault Bool, thatDefault Any) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a BoolArray) ZipAllTuple2List(l2 Tuple2List, thisDefault Bool, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllBoolArray(a2 BoolArray, thisDefault String, thatDefault Bool) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllStringArray(a2 StringArray, thisDefault String, thatDefault String) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllIntArray(a2 IntArray, thisDefault String, thatDefault Int) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllInt64Array(a2 Int64Array, thisDefault String, thatDefault Int64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllByteArray(a2 ByteArray, thisDefault String, thatDefault Byte) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllRuneArray(a2 RuneArray, thisDefault String, thatDefault Rune) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllFloat32Array(a2 Float32Array, thisDefault String, thatDefault Float32) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllFloat64Array(a2 Float64Array, thisDefault String, thatDefault Float64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllAnyArray(a2 AnyArray, thisDefault String, thatDefault Any) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllTuple2Array(a2 Tuple2Array, thisDefault String, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllBoolList(l2 BoolList, thisDefault String, thatDefault Bool) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllStringList(l2 StringList, thisDefault String, thatDefault String) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllIntList(l2 IntList, thisDefault String, thatDefault Int) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllInt64List(l2 Int64List, thisDefault String, thatDefault Int64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllByteList(l2 ByteList, thisDefault String, thatDefault Byte) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllRuneList(l2 RuneList, thisDefault String, thatDefault Rune) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllFloat32List(l2 Float32List, thisDefault String, thatDefault Float32) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllFloat64List(l2 Float64List, thisDefault String, thatDefault Float64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllAnyList(l2 AnyList, thisDefault String, thatDefault Any) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a StringArray) ZipAllTuple2List(l2 Tuple2List, thisDefault String, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllBoolArray(a2 BoolArray, thisDefault Int, thatDefault Bool) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllStringArray(a2 StringArray, thisDefault Int, thatDefault String) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllIntArray(a2 IntArray, thisDefault Int, thatDefault Int) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllInt64Array(a2 Int64Array, thisDefault Int, thatDefault Int64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllByteArray(a2 ByteArray, thisDefault Int, thatDefault Byte) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllRuneArray(a2 RuneArray, thisDefault Int, thatDefault Rune) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllFloat32Array(a2 Float32Array, thisDefault Int, thatDefault Float32) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllFloat64Array(a2 Float64Array, thisDefault Int, thatDefault Float64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllAnyArray(a2 AnyArray, thisDefault Int, thatDefault Any) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllTuple2Array(a2 Tuple2Array, thisDefault Int, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllBoolList(l2 BoolList, thisDefault Int, thatDefault Bool) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllStringList(l2 StringList, thisDefault Int, thatDefault String) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllIntList(l2 IntList, thisDefault Int, thatDefault Int) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllInt64List(l2 Int64List, thisDefault Int, thatDefault Int64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllByteList(l2 ByteList, thisDefault Int, thatDefault Byte) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllRuneList(l2 RuneList, thisDefault Int, thatDefault Rune) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllFloat32List(l2 Float32List, thisDefault Int, thatDefault Float32) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllFloat64List(l2 Float64List, thisDefault Int, thatDefault Float64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllAnyList(l2 AnyList, thisDefault Int, thatDefault Any) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a IntArray) ZipAllTuple2List(l2 Tuple2List, thisDefault Int, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllBoolArray(a2 BoolArray, thisDefault Int64, thatDefault Bool) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllStringArray(a2 StringArray, thisDefault Int64, thatDefault String) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllIntArray(a2 IntArray, thisDefault Int64, thatDefault Int) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllInt64Array(a2 Int64Array, thisDefault Int64, thatDefault Int64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllByteArray(a2 ByteArray, thisDefault Int64, thatDefault Byte) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllRuneArray(a2 RuneArray, thisDefault Int64, thatDefault Rune) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllFloat32Array(a2 Float32Array, thisDefault Int64, thatDefault Float32) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllFloat64Array(a2 Float64Array, thisDefault Int64, thatDefault Float64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllAnyArray(a2 AnyArray, thisDefault Int64, thatDefault Any) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllTuple2Array(a2 Tuple2Array, thisDefault Int64, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllBoolList(l2 BoolList, thisDefault Int64, thatDefault Bool) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllStringList(l2 StringList, thisDefault Int64, thatDefault String) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllIntList(l2 IntList, thisDefault Int64, thatDefault Int) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllInt64List(l2 Int64List, thisDefault Int64, thatDefault Int64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllByteList(l2 ByteList, thisDefault Int64, thatDefault Byte) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllRuneList(l2 RuneList, thisDefault Int64, thatDefault Rune) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllFloat32List(l2 Float32List, thisDefault Int64, thatDefault Float32) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllFloat64List(l2 Float64List, thisDefault Int64, thatDefault Float64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllAnyList(l2 AnyList, thisDefault Int64, thatDefault Any) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Int64Array) ZipAllTuple2List(l2 Tuple2List, thisDefault Int64, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllBoolArray(a2 BoolArray, thisDefault Byte, thatDefault Bool) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllStringArray(a2 StringArray, thisDefault Byte, thatDefault String) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllIntArray(a2 IntArray, thisDefault Byte, thatDefault Int) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllInt64Array(a2 Int64Array, thisDefault Byte, thatDefault Int64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllByteArray(a2 ByteArray, thisDefault Byte, thatDefault Byte) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllRuneArray(a2 RuneArray, thisDefault Byte, thatDefault Rune) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllFloat32Array(a2 Float32Array, thisDefault Byte, thatDefault Float32) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllFloat64Array(a2 Float64Array, thisDefault Byte, thatDefault Float64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllAnyArray(a2 AnyArray, thisDefault Byte, thatDefault Any) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllTuple2Array(a2 Tuple2Array, thisDefault Byte, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllBoolList(l2 BoolList, thisDefault Byte, thatDefault Bool) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllStringList(l2 StringList, thisDefault Byte, thatDefault String) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllIntList(l2 IntList, thisDefault Byte, thatDefault Int) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllInt64List(l2 Int64List, thisDefault Byte, thatDefault Int64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllByteList(l2 ByteList, thisDefault Byte, thatDefault Byte) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllRuneList(l2 RuneList, thisDefault Byte, thatDefault Rune) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllFloat32List(l2 Float32List, thisDefault Byte, thatDefault Float32) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllFloat64List(l2 Float64List, thisDefault Byte, thatDefault Float64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllAnyList(l2 AnyList, thisDefault Byte, thatDefault Any) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a ByteArray) ZipAllTuple2List(l2 Tuple2List, thisDefault Byte, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllBoolArray(a2 BoolArray, thisDefault Rune, thatDefault Bool) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllStringArray(a2 StringArray, thisDefault Rune, thatDefault String) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllIntArray(a2 IntArray, thisDefault Rune, thatDefault Int) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllInt64Array(a2 Int64Array, thisDefault Rune, thatDefault Int64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllByteArray(a2 ByteArray, thisDefault Rune, thatDefault Byte) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllRuneArray(a2 RuneArray, thisDefault Rune, thatDefault Rune) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllFloat32Array(a2 Float32Array, thisDefault Rune, thatDefault Float32) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllFloat64Array(a2 Float64Array, thisDefault Rune, thatDefault Float64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllAnyArray(a2 AnyArray, thisDefault Rune, thatDefault Any) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllTuple2Array(a2 Tuple2Array, thisDefault Rune, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllBoolList(l2 BoolList, thisDefault Rune, thatDefault Bool) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllStringList(l2 StringList, thisDefault Rune, thatDefault String) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllIntList(l2 IntList, thisDefault Rune, thatDefault Int) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllInt64List(l2 Int64List, thisDefault Rune, thatDefault Int64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllByteList(l2 ByteList, thisDefault Rune, thatDefault Byte) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllRuneList(l2 RuneList, thisDefault Rune, thatDefault Rune) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllFloat32List(l2 Float32List, thisDefault Rune, thatDefault Float32) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllFloat64List(l2 Float64List, thisDefault Rune, thatDefault Float64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllAnyList(l2 AnyList, thisDefault Rune, thatDefault Any) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a RuneArray) ZipAllTuple2List(l2 Tuple2List, thisDefault Rune, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllBoolArray(a2 BoolArray, thisDefault Float32, thatDefault Bool) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllStringArray(a2 StringArray, thisDefault Float32, thatDefault String) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllIntArray(a2 IntArray, thisDefault Float32, thatDefault Int) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllInt64Array(a2 Int64Array, thisDefault Float32, thatDefault Int64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllByteArray(a2 ByteArray, thisDefault Float32, thatDefault Byte) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllRuneArray(a2 RuneArray, thisDefault Float32, thatDefault Rune) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllFloat32Array(a2 Float32Array, thisDefault Float32, thatDefault Float32) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllFloat64Array(a2 Float64Array, thisDefault Float32, thatDefault Float64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllAnyArray(a2 AnyArray, thisDefault Float32, thatDefault Any) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllTuple2Array(a2 Tuple2Array, thisDefault Float32, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllBoolList(l2 BoolList, thisDefault Float32, thatDefault Bool) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllStringList(l2 StringList, thisDefault Float32, thatDefault String) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllIntList(l2 IntList, thisDefault Float32, thatDefault Int) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllInt64List(l2 Int64List, thisDefault Float32, thatDefault Int64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllByteList(l2 ByteList, thisDefault Float32, thatDefault Byte) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllRuneList(l2 RuneList, thisDefault Float32, thatDefault Rune) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllFloat32List(l2 Float32List, thisDefault Float32, thatDefault Float32) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllFloat64List(l2 Float64List, thisDefault Float32, thatDefault Float64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllAnyList(l2 AnyList, thisDefault Float32, thatDefault Any) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float32Array) ZipAllTuple2List(l2 Tuple2List, thisDefault Float32, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllBoolArray(a2 BoolArray, thisDefault Float64, thatDefault Bool) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllStringArray(a2 StringArray, thisDefault Float64, thatDefault String) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllIntArray(a2 IntArray, thisDefault Float64, thatDefault Int) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllInt64Array(a2 Int64Array, thisDefault Float64, thatDefault Int64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllByteArray(a2 ByteArray, thisDefault Float64, thatDefault Byte) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllRuneArray(a2 RuneArray, thisDefault Float64, thatDefault Rune) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllFloat32Array(a2 Float32Array, thisDefault Float64, thatDefault Float32) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllFloat64Array(a2 Float64Array, thisDefault Float64, thatDefault Float64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllAnyArray(a2 AnyArray, thisDefault Float64, thatDefault Any) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllTuple2Array(a2 Tuple2Array, thisDefault Float64, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllBoolList(l2 BoolList, thisDefault Float64, thatDefault Bool) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllStringList(l2 StringList, thisDefault Float64, thatDefault String) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllIntList(l2 IntList, thisDefault Float64, thatDefault Int) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllInt64List(l2 Int64List, thisDefault Float64, thatDefault Int64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllByteList(l2 ByteList, thisDefault Float64, thatDefault Byte) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllRuneList(l2 RuneList, thisDefault Float64, thatDefault Rune) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllFloat32List(l2 Float32List, thisDefault Float64, thatDefault Float32) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllFloat64List(l2 Float64List, thisDefault Float64, thatDefault Float64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllAnyList(l2 AnyList, thisDefault Float64, thatDefault Any) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Float64Array) ZipAllTuple2List(l2 Tuple2List, thisDefault Float64, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllBoolArray(a2 BoolArray, thisDefault Any, thatDefault Bool) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllStringArray(a2 StringArray, thisDefault Any, thatDefault String) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllIntArray(a2 IntArray, thisDefault Any, thatDefault Int) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllInt64Array(a2 Int64Array, thisDefault Any, thatDefault Int64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllByteArray(a2 ByteArray, thisDefault Any, thatDefault Byte) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllRuneArray(a2 RuneArray, thisDefault Any, thatDefault Rune) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllFloat32Array(a2 Float32Array, thisDefault Any, thatDefault Float32) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllFloat64Array(a2 Float64Array, thisDefault Any, thatDefault Float64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllAnyArray(a2 AnyArray, thisDefault Any, thatDefault Any) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllTuple2Array(a2 Tuple2Array, thisDefault Any, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllBoolList(l2 BoolList, thisDefault Any, thatDefault Bool) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllStringList(l2 StringList, thisDefault Any, thatDefault String) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllIntList(l2 IntList, thisDefault Any, thatDefault Int) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllInt64List(l2 Int64List, thisDefault Any, thatDefault Int64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllByteList(l2 ByteList, thisDefault Any, thatDefault Byte) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllRuneList(l2 RuneList, thisDefault Any, thatDefault Rune) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllFloat32List(l2 Float32List, thisDefault Any, thatDefault Float32) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllFloat64List(l2 Float64List, thisDefault Any, thatDefault Float64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllAnyList(l2 AnyList, thisDefault Any, thatDefault Any) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a AnyArray) ZipAllTuple2List(l2 Tuple2List, thisDefault Any, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllBoolArray(a2 BoolArray, thisDefault Tuple2, thatDefault Bool) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllStringArray(a2 StringArray, thisDefault Tuple2, thatDefault String) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllIntArray(a2 IntArray, thisDefault Tuple2, thatDefault Int) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllInt64Array(a2 Int64Array, thisDefault Tuple2, thatDefault Int64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllByteArray(a2 ByteArray, thisDefault Tuple2, thatDefault Byte) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllRuneArray(a2 RuneArray, thisDefault Tuple2, thatDefault Rune) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllFloat32Array(a2 Float32Array, thisDefault Tuple2, thatDefault Float32) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllFloat64Array(a2 Float64Array, thisDefault Tuple2, thatDefault Float64) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllAnyArray(a2 AnyArray, thisDefault Tuple2, thatDefault Any) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllTuple2Array(a2 Tuple2Array, thisDefault Tuple2, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); len2 := len(a2); maxLen := int(Int(len1).Max(Int(len2)))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  for i := 0; i < maxLen; i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if i < len2 { e2 = a2[i] } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllBoolList(l2 BoolList, thisDefault Tuple2, thatDefault Bool) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllStringList(l2 StringList, thisDefault Tuple2, thatDefault String) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllIntList(l2 IntList, thisDefault Tuple2, thatDefault Int) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllInt64List(l2 Int64List, thisDefault Tuple2, thatDefault Int64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllByteList(l2 ByteList, thisDefault Tuple2, thatDefault Byte) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllRuneList(l2 RuneList, thisDefault Tuple2, thatDefault Rune) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllFloat32List(l2 Float32List, thisDefault Tuple2, thatDefault Float32) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllFloat64List(l2 Float64List, thisDefault Tuple2, thatDefault Float64) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllAnyList(l2 AnyList, thisDefault Tuple2, thatDefault Any) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}
func (a Tuple2Array) ZipAllTuple2List(l2 Tuple2List, thisDefault Tuple2, thatDefault Tuple2) Tuple2Array {
  len1 := len(a); maxLen := int(Int(len1).Max(Int(l2.Size())))
  zipped := make([]Tuple2, maxLen)
  var e1, e2 Any
  xs := l2
  for i := 0; i < maxLen && xs.NonEmpty(); i ++ {
    if i < len1 { e1 = a[i] } else { e1 = thisDefault }
    if xs.NonEmpty() { e2 = *xs.head; xs = *xs.tail } else { e2 = thatDefault }
    zipped[i] = Tuple2 { e1, e2 }
  }
  return zipped
}