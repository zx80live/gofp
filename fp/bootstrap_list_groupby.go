// bootstrap_list_groupby.go
// DO NOT EDIT THIS FILE WAS GENERATED AUTOMATICALLY BY https://github.com/zx80live/gofp-bootstrap

package fp


func (l BoolList) GroupByBool(f func(bool) bool) map[bool]BoolList {
	m := make(map[bool]BoolList)

	l.Foreach(func(e bool) {
		key := f(e)
		var group BoolList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilBool
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l StringList) GroupByString(f func(string) string) map[string]StringList {
	m := make(map[string]StringList)

	l.Foreach(func(e string) {
		key := f(e)
		var group StringList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilString
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l IntList) GroupByInt(f func(int) int) map[int]IntList {
	m := make(map[int]IntList)

	l.Foreach(func(e int) {
		key := f(e)
		var group IntList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilInt
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Int64List) GroupByInt64(f func(int64) int64) map[int64]Int64List {
	m := make(map[int64]Int64List)

	l.Foreach(func(e int64) {
		key := f(e)
		var group Int64List

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilInt64
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l ByteList) GroupByByte(f func(byte) byte) map[byte]ByteList {
	m := make(map[byte]ByteList)

	l.Foreach(func(e byte) {
		key := f(e)
		var group ByteList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilByte
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l RuneList) GroupByRune(f func(rune) rune) map[rune]RuneList {
	m := make(map[rune]RuneList)

	l.Foreach(func(e rune) {
		key := f(e)
		var group RuneList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilRune
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Float32List) GroupByFloat32(f func(float32) float32) map[float32]Float32List {
	m := make(map[float32]Float32List)

	l.Foreach(func(e float32) {
		key := f(e)
		var group Float32List

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilFloat32
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Float64List) GroupByFloat64(f func(float64) float64) map[float64]Float64List {
	m := make(map[float64]Float64List)

	l.Foreach(func(e float64) {
		key := f(e)
		var group Float64List

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilFloat64
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l AnyList) GroupByAny(f func(Any) Any) map[Any]AnyList {
	m := make(map[Any]AnyList)

	l.Foreach(func(e Any) {
		key := f(e)
		var group AnyList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilAny
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Tuple2List) GroupByTuple2(f func(Tuple2) Tuple2) map[Tuple2]Tuple2List {
	m := make(map[Tuple2]Tuple2List)

	l.Foreach(func(e Tuple2) {
		key := f(e)
		var group Tuple2List

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilTuple2
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l BoolOptionList) GroupByBoolOption(f func(BoolOption) BoolOption) map[BoolOption]BoolOptionList {
	m := make(map[BoolOption]BoolOptionList)

	l.Foreach(func(e BoolOption) {
		key := f(e)
		var group BoolOptionList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilBoolOption
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l StringOptionList) GroupByStringOption(f func(StringOption) StringOption) map[StringOption]StringOptionList {
	m := make(map[StringOption]StringOptionList)

	l.Foreach(func(e StringOption) {
		key := f(e)
		var group StringOptionList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilStringOption
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l IntOptionList) GroupByIntOption(f func(IntOption) IntOption) map[IntOption]IntOptionList {
	m := make(map[IntOption]IntOptionList)

	l.Foreach(func(e IntOption) {
		key := f(e)
		var group IntOptionList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilIntOption
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Int64OptionList) GroupByInt64Option(f func(Int64Option) Int64Option) map[Int64Option]Int64OptionList {
	m := make(map[Int64Option]Int64OptionList)

	l.Foreach(func(e Int64Option) {
		key := f(e)
		var group Int64OptionList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilInt64Option
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l ByteOptionList) GroupByByteOption(f func(ByteOption) ByteOption) map[ByteOption]ByteOptionList {
	m := make(map[ByteOption]ByteOptionList)

	l.Foreach(func(e ByteOption) {
		key := f(e)
		var group ByteOptionList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilByteOption
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l RuneOptionList) GroupByRuneOption(f func(RuneOption) RuneOption) map[RuneOption]RuneOptionList {
	m := make(map[RuneOption]RuneOptionList)

	l.Foreach(func(e RuneOption) {
		key := f(e)
		var group RuneOptionList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilRuneOption
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Float32OptionList) GroupByFloat32Option(f func(Float32Option) Float32Option) map[Float32Option]Float32OptionList {
	m := make(map[Float32Option]Float32OptionList)

	l.Foreach(func(e Float32Option) {
		key := f(e)
		var group Float32OptionList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilFloat32Option
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Float64OptionList) GroupByFloat64Option(f func(Float64Option) Float64Option) map[Float64Option]Float64OptionList {
	m := make(map[Float64Option]Float64OptionList)

	l.Foreach(func(e Float64Option) {
		key := f(e)
		var group Float64OptionList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilFloat64Option
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l AnyOptionList) GroupByAnyOption(f func(AnyOption) AnyOption) map[AnyOption]AnyOptionList {
	m := make(map[AnyOption]AnyOptionList)

	l.Foreach(func(e AnyOption) {
		key := f(e)
		var group AnyOptionList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilAnyOption
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Tuple2OptionList) GroupByTuple2Option(f func(Tuple2Option) Tuple2Option) map[Tuple2Option]Tuple2OptionList {
	m := make(map[Tuple2Option]Tuple2OptionList)

	l.Foreach(func(e Tuple2Option) {
		key := f(e)
		var group Tuple2OptionList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilTuple2Option
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l BoolListList) GroupByBoolList(f func(BoolList) BoolList) map[BoolList]BoolListList {
	m := make(map[BoolList]BoolListList)

	l.Foreach(func(e BoolList) {
		key := f(e)
		var group BoolListList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilBoolList
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l StringListList) GroupByStringList(f func(StringList) StringList) map[StringList]StringListList {
	m := make(map[StringList]StringListList)

	l.Foreach(func(e StringList) {
		key := f(e)
		var group StringListList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilStringList
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l IntListList) GroupByIntList(f func(IntList) IntList) map[IntList]IntListList {
	m := make(map[IntList]IntListList)

	l.Foreach(func(e IntList) {
		key := f(e)
		var group IntListList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilIntList
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Int64ListList) GroupByInt64List(f func(Int64List) Int64List) map[Int64List]Int64ListList {
	m := make(map[Int64List]Int64ListList)

	l.Foreach(func(e Int64List) {
		key := f(e)
		var group Int64ListList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilInt64List
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l ByteListList) GroupByByteList(f func(ByteList) ByteList) map[ByteList]ByteListList {
	m := make(map[ByteList]ByteListList)

	l.Foreach(func(e ByteList) {
		key := f(e)
		var group ByteListList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilByteList
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l RuneListList) GroupByRuneList(f func(RuneList) RuneList) map[RuneList]RuneListList {
	m := make(map[RuneList]RuneListList)

	l.Foreach(func(e RuneList) {
		key := f(e)
		var group RuneListList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilRuneList
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Float32ListList) GroupByFloat32List(f func(Float32List) Float32List) map[Float32List]Float32ListList {
	m := make(map[Float32List]Float32ListList)

	l.Foreach(func(e Float32List) {
		key := f(e)
		var group Float32ListList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilFloat32List
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Float64ListList) GroupByFloat64List(f func(Float64List) Float64List) map[Float64List]Float64ListList {
	m := make(map[Float64List]Float64ListList)

	l.Foreach(func(e Float64List) {
		key := f(e)
		var group Float64ListList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilFloat64List
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l AnyListList) GroupByAnyList(f func(AnyList) AnyList) map[AnyList]AnyListList {
	m := make(map[AnyList]AnyListList)

	l.Foreach(func(e AnyList) {
		key := f(e)
		var group AnyListList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilAnyList
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }
func (l Tuple2ListList) GroupByTuple2List(f func(Tuple2List) Tuple2List) map[Tuple2List]Tuple2ListList {
	m := make(map[Tuple2List]Tuple2ListList)

	l.Foreach(func(e Tuple2List) {
		key := f(e)
		var group Tuple2ListList

		if value, found := m[key]; found {
			group = value
		} else {
			group = NilTuple2List
		}
		group = group.Cons(e)
		m[key] = group
	})

	return m }