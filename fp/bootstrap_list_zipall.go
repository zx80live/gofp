// bootstrap_list_zipall.go
// DO NOT EDIT THIS FILE WAS GENERATED AUTOMATICALLY BY https://github.com/zx80live/gofp-bootstrap

package fp

func (l BoolList) ZipAllBoolList(l2 BoolList, thisDefault Bool, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllStringList(l2 StringList, thisDefault Bool, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllIntList(l2 IntList, thisDefault Bool, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllInt64List(l2 Int64List, thisDefault Bool, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllByteList(l2 ByteList, thisDefault Bool, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllRuneList(l2 RuneList, thisDefault Bool, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllFloat32List(l2 Float32List, thisDefault Bool, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllFloat64List(l2 Float64List, thisDefault Bool, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllAnyList(l2 AnyList, thisDefault Bool, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllTuple2List(l2 Tuple2List, thisDefault Bool, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllBoolArrayList(l2 BoolArrayList, thisDefault Bool, thatDefault BoolArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllStringArrayList(l2 StringArrayList, thisDefault Bool, thatDefault StringArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllIntArrayList(l2 IntArrayList, thisDefault Bool, thatDefault IntArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllInt64ArrayList(l2 Int64ArrayList, thisDefault Bool, thatDefault Int64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllByteArrayList(l2 ByteArrayList, thisDefault Bool, thatDefault ByteArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllRuneArrayList(l2 RuneArrayList, thisDefault Bool, thatDefault RuneArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllFloat32ArrayList(l2 Float32ArrayList, thisDefault Bool, thatDefault Float32Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllFloat64ArrayList(l2 Float64ArrayList, thisDefault Bool, thatDefault Float64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllAnyArrayList(l2 AnyArrayList, thisDefault Bool, thatDefault AnyArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllTuple2ArrayList(l2 Tuple2ArrayList, thisDefault Bool, thatDefault Tuple2Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllBoolOptionList(l2 BoolOptionList, thisDefault Bool, thatDefault BoolOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllStringOptionList(l2 StringOptionList, thisDefault Bool, thatDefault StringOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllIntOptionList(l2 IntOptionList, thisDefault Bool, thatDefault IntOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllInt64OptionList(l2 Int64OptionList, thisDefault Bool, thatDefault Int64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllByteOptionList(l2 ByteOptionList, thisDefault Bool, thatDefault ByteOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllRuneOptionList(l2 RuneOptionList, thisDefault Bool, thatDefault RuneOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllFloat32OptionList(l2 Float32OptionList, thisDefault Bool, thatDefault Float32Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllFloat64OptionList(l2 Float64OptionList, thisDefault Bool, thatDefault Float64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllAnyOptionList(l2 AnyOptionList, thisDefault Bool, thatDefault AnyOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllTuple2OptionList(l2 Tuple2OptionList, thisDefault Bool, thatDefault Tuple2Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllBoolListList(l2 BoolListList, thisDefault Bool, thatDefault BoolList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllStringListList(l2 StringListList, thisDefault Bool, thatDefault StringList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllIntListList(l2 IntListList, thisDefault Bool, thatDefault IntList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllInt64ListList(l2 Int64ListList, thisDefault Bool, thatDefault Int64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllByteListList(l2 ByteListList, thisDefault Bool, thatDefault ByteList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllRuneListList(l2 RuneListList, thisDefault Bool, thatDefault RuneList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllFloat32ListList(l2 Float32ListList, thisDefault Bool, thatDefault Float32List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllFloat64ListList(l2 Float64ListList, thisDefault Bool, thatDefault Float64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllAnyListList(l2 AnyListList, thisDefault Bool, thatDefault AnyList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllTuple2ListList(l2 Tuple2ListList, thisDefault Bool, thatDefault Tuple2List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllBoolArray(l2 BoolArray, thisDefault Bool, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllStringArray(l2 StringArray, thisDefault Bool, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllIntArray(l2 IntArray, thisDefault Bool, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllInt64Array(l2 Int64Array, thisDefault Bool, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllByteArray(l2 ByteArray, thisDefault Bool, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllRuneArray(l2 RuneArray, thisDefault Bool, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllFloat32Array(l2 Float32Array, thisDefault Bool, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllFloat64Array(l2 Float64Array, thisDefault Bool, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllAnyArray(l2 AnyArray, thisDefault Bool, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l BoolList) ZipAllTuple2Array(l2 Tuple2Array, thisDefault Bool, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllBoolList(l2 BoolList, thisDefault String, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllStringList(l2 StringList, thisDefault String, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllIntList(l2 IntList, thisDefault String, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllInt64List(l2 Int64List, thisDefault String, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllByteList(l2 ByteList, thisDefault String, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllRuneList(l2 RuneList, thisDefault String, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllFloat32List(l2 Float32List, thisDefault String, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllFloat64List(l2 Float64List, thisDefault String, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllAnyList(l2 AnyList, thisDefault String, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllTuple2List(l2 Tuple2List, thisDefault String, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllBoolArrayList(l2 BoolArrayList, thisDefault String, thatDefault BoolArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllStringArrayList(l2 StringArrayList, thisDefault String, thatDefault StringArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllIntArrayList(l2 IntArrayList, thisDefault String, thatDefault IntArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllInt64ArrayList(l2 Int64ArrayList, thisDefault String, thatDefault Int64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllByteArrayList(l2 ByteArrayList, thisDefault String, thatDefault ByteArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllRuneArrayList(l2 RuneArrayList, thisDefault String, thatDefault RuneArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllFloat32ArrayList(l2 Float32ArrayList, thisDefault String, thatDefault Float32Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllFloat64ArrayList(l2 Float64ArrayList, thisDefault String, thatDefault Float64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllAnyArrayList(l2 AnyArrayList, thisDefault String, thatDefault AnyArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllTuple2ArrayList(l2 Tuple2ArrayList, thisDefault String, thatDefault Tuple2Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllBoolOptionList(l2 BoolOptionList, thisDefault String, thatDefault BoolOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllStringOptionList(l2 StringOptionList, thisDefault String, thatDefault StringOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllIntOptionList(l2 IntOptionList, thisDefault String, thatDefault IntOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllInt64OptionList(l2 Int64OptionList, thisDefault String, thatDefault Int64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllByteOptionList(l2 ByteOptionList, thisDefault String, thatDefault ByteOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllRuneOptionList(l2 RuneOptionList, thisDefault String, thatDefault RuneOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllFloat32OptionList(l2 Float32OptionList, thisDefault String, thatDefault Float32Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllFloat64OptionList(l2 Float64OptionList, thisDefault String, thatDefault Float64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllAnyOptionList(l2 AnyOptionList, thisDefault String, thatDefault AnyOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllTuple2OptionList(l2 Tuple2OptionList, thisDefault String, thatDefault Tuple2Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllBoolListList(l2 BoolListList, thisDefault String, thatDefault BoolList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllStringListList(l2 StringListList, thisDefault String, thatDefault StringList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllIntListList(l2 IntListList, thisDefault String, thatDefault IntList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllInt64ListList(l2 Int64ListList, thisDefault String, thatDefault Int64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllByteListList(l2 ByteListList, thisDefault String, thatDefault ByteList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllRuneListList(l2 RuneListList, thisDefault String, thatDefault RuneList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllFloat32ListList(l2 Float32ListList, thisDefault String, thatDefault Float32List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllFloat64ListList(l2 Float64ListList, thisDefault String, thatDefault Float64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllAnyListList(l2 AnyListList, thisDefault String, thatDefault AnyList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllTuple2ListList(l2 Tuple2ListList, thisDefault String, thatDefault Tuple2List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllBoolArray(l2 BoolArray, thisDefault String, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllStringArray(l2 StringArray, thisDefault String, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllIntArray(l2 IntArray, thisDefault String, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllInt64Array(l2 Int64Array, thisDefault String, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllByteArray(l2 ByteArray, thisDefault String, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllRuneArray(l2 RuneArray, thisDefault String, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllFloat32Array(l2 Float32Array, thisDefault String, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllFloat64Array(l2 Float64Array, thisDefault String, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllAnyArray(l2 AnyArray, thisDefault String, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l StringList) ZipAllTuple2Array(l2 Tuple2Array, thisDefault String, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllBoolList(l2 BoolList, thisDefault Int, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllStringList(l2 StringList, thisDefault Int, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllIntList(l2 IntList, thisDefault Int, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllInt64List(l2 Int64List, thisDefault Int, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllByteList(l2 ByteList, thisDefault Int, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllRuneList(l2 RuneList, thisDefault Int, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllFloat32List(l2 Float32List, thisDefault Int, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllFloat64List(l2 Float64List, thisDefault Int, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllAnyList(l2 AnyList, thisDefault Int, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllTuple2List(l2 Tuple2List, thisDefault Int, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllBoolArrayList(l2 BoolArrayList, thisDefault Int, thatDefault BoolArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllStringArrayList(l2 StringArrayList, thisDefault Int, thatDefault StringArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllIntArrayList(l2 IntArrayList, thisDefault Int, thatDefault IntArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllInt64ArrayList(l2 Int64ArrayList, thisDefault Int, thatDefault Int64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllByteArrayList(l2 ByteArrayList, thisDefault Int, thatDefault ByteArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllRuneArrayList(l2 RuneArrayList, thisDefault Int, thatDefault RuneArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllFloat32ArrayList(l2 Float32ArrayList, thisDefault Int, thatDefault Float32Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllFloat64ArrayList(l2 Float64ArrayList, thisDefault Int, thatDefault Float64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllAnyArrayList(l2 AnyArrayList, thisDefault Int, thatDefault AnyArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllTuple2ArrayList(l2 Tuple2ArrayList, thisDefault Int, thatDefault Tuple2Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllBoolOptionList(l2 BoolOptionList, thisDefault Int, thatDefault BoolOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllStringOptionList(l2 StringOptionList, thisDefault Int, thatDefault StringOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllIntOptionList(l2 IntOptionList, thisDefault Int, thatDefault IntOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllInt64OptionList(l2 Int64OptionList, thisDefault Int, thatDefault Int64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllByteOptionList(l2 ByteOptionList, thisDefault Int, thatDefault ByteOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllRuneOptionList(l2 RuneOptionList, thisDefault Int, thatDefault RuneOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllFloat32OptionList(l2 Float32OptionList, thisDefault Int, thatDefault Float32Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllFloat64OptionList(l2 Float64OptionList, thisDefault Int, thatDefault Float64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllAnyOptionList(l2 AnyOptionList, thisDefault Int, thatDefault AnyOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllTuple2OptionList(l2 Tuple2OptionList, thisDefault Int, thatDefault Tuple2Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllBoolListList(l2 BoolListList, thisDefault Int, thatDefault BoolList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllStringListList(l2 StringListList, thisDefault Int, thatDefault StringList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllIntListList(l2 IntListList, thisDefault Int, thatDefault IntList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllInt64ListList(l2 Int64ListList, thisDefault Int, thatDefault Int64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllByteListList(l2 ByteListList, thisDefault Int, thatDefault ByteList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllRuneListList(l2 RuneListList, thisDefault Int, thatDefault RuneList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllFloat32ListList(l2 Float32ListList, thisDefault Int, thatDefault Float32List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllFloat64ListList(l2 Float64ListList, thisDefault Int, thatDefault Float64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllAnyListList(l2 AnyListList, thisDefault Int, thatDefault AnyList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllTuple2ListList(l2 Tuple2ListList, thisDefault Int, thatDefault Tuple2List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllBoolArray(l2 BoolArray, thisDefault Int, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllStringArray(l2 StringArray, thisDefault Int, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllIntArray(l2 IntArray, thisDefault Int, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllInt64Array(l2 Int64Array, thisDefault Int, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllByteArray(l2 ByteArray, thisDefault Int, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllRuneArray(l2 RuneArray, thisDefault Int, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllFloat32Array(l2 Float32Array, thisDefault Int, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllFloat64Array(l2 Float64Array, thisDefault Int, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllAnyArray(l2 AnyArray, thisDefault Int, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l IntList) ZipAllTuple2Array(l2 Tuple2Array, thisDefault Int, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllBoolList(l2 BoolList, thisDefault Int64, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllStringList(l2 StringList, thisDefault Int64, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllIntList(l2 IntList, thisDefault Int64, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllInt64List(l2 Int64List, thisDefault Int64, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllByteList(l2 ByteList, thisDefault Int64, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllRuneList(l2 RuneList, thisDefault Int64, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllFloat32List(l2 Float32List, thisDefault Int64, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllFloat64List(l2 Float64List, thisDefault Int64, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllAnyList(l2 AnyList, thisDefault Int64, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllTuple2List(l2 Tuple2List, thisDefault Int64, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllBoolArrayList(l2 BoolArrayList, thisDefault Int64, thatDefault BoolArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllStringArrayList(l2 StringArrayList, thisDefault Int64, thatDefault StringArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllIntArrayList(l2 IntArrayList, thisDefault Int64, thatDefault IntArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllInt64ArrayList(l2 Int64ArrayList, thisDefault Int64, thatDefault Int64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllByteArrayList(l2 ByteArrayList, thisDefault Int64, thatDefault ByteArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllRuneArrayList(l2 RuneArrayList, thisDefault Int64, thatDefault RuneArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllFloat32ArrayList(l2 Float32ArrayList, thisDefault Int64, thatDefault Float32Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllFloat64ArrayList(l2 Float64ArrayList, thisDefault Int64, thatDefault Float64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllAnyArrayList(l2 AnyArrayList, thisDefault Int64, thatDefault AnyArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllTuple2ArrayList(l2 Tuple2ArrayList, thisDefault Int64, thatDefault Tuple2Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllBoolOptionList(l2 BoolOptionList, thisDefault Int64, thatDefault BoolOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllStringOptionList(l2 StringOptionList, thisDefault Int64, thatDefault StringOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllIntOptionList(l2 IntOptionList, thisDefault Int64, thatDefault IntOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllInt64OptionList(l2 Int64OptionList, thisDefault Int64, thatDefault Int64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllByteOptionList(l2 ByteOptionList, thisDefault Int64, thatDefault ByteOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllRuneOptionList(l2 RuneOptionList, thisDefault Int64, thatDefault RuneOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllFloat32OptionList(l2 Float32OptionList, thisDefault Int64, thatDefault Float32Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllFloat64OptionList(l2 Float64OptionList, thisDefault Int64, thatDefault Float64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllAnyOptionList(l2 AnyOptionList, thisDefault Int64, thatDefault AnyOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllTuple2OptionList(l2 Tuple2OptionList, thisDefault Int64, thatDefault Tuple2Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllBoolListList(l2 BoolListList, thisDefault Int64, thatDefault BoolList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllStringListList(l2 StringListList, thisDefault Int64, thatDefault StringList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllIntListList(l2 IntListList, thisDefault Int64, thatDefault IntList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllInt64ListList(l2 Int64ListList, thisDefault Int64, thatDefault Int64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllByteListList(l2 ByteListList, thisDefault Int64, thatDefault ByteList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllRuneListList(l2 RuneListList, thisDefault Int64, thatDefault RuneList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllFloat32ListList(l2 Float32ListList, thisDefault Int64, thatDefault Float32List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllFloat64ListList(l2 Float64ListList, thisDefault Int64, thatDefault Float64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllAnyListList(l2 AnyListList, thisDefault Int64, thatDefault AnyList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllTuple2ListList(l2 Tuple2ListList, thisDefault Int64, thatDefault Tuple2List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllBoolArray(l2 BoolArray, thisDefault Int64, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllStringArray(l2 StringArray, thisDefault Int64, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllIntArray(l2 IntArray, thisDefault Int64, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllInt64Array(l2 Int64Array, thisDefault Int64, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllByteArray(l2 ByteArray, thisDefault Int64, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllRuneArray(l2 RuneArray, thisDefault Int64, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllFloat32Array(l2 Float32Array, thisDefault Int64, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllFloat64Array(l2 Float64Array, thisDefault Int64, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllAnyArray(l2 AnyArray, thisDefault Int64, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Int64List) ZipAllTuple2Array(l2 Tuple2Array, thisDefault Int64, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllBoolList(l2 BoolList, thisDefault Byte, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllStringList(l2 StringList, thisDefault Byte, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllIntList(l2 IntList, thisDefault Byte, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllInt64List(l2 Int64List, thisDefault Byte, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllByteList(l2 ByteList, thisDefault Byte, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllRuneList(l2 RuneList, thisDefault Byte, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllFloat32List(l2 Float32List, thisDefault Byte, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllFloat64List(l2 Float64List, thisDefault Byte, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllAnyList(l2 AnyList, thisDefault Byte, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllTuple2List(l2 Tuple2List, thisDefault Byte, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllBoolArrayList(l2 BoolArrayList, thisDefault Byte, thatDefault BoolArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllStringArrayList(l2 StringArrayList, thisDefault Byte, thatDefault StringArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllIntArrayList(l2 IntArrayList, thisDefault Byte, thatDefault IntArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllInt64ArrayList(l2 Int64ArrayList, thisDefault Byte, thatDefault Int64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllByteArrayList(l2 ByteArrayList, thisDefault Byte, thatDefault ByteArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllRuneArrayList(l2 RuneArrayList, thisDefault Byte, thatDefault RuneArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllFloat32ArrayList(l2 Float32ArrayList, thisDefault Byte, thatDefault Float32Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllFloat64ArrayList(l2 Float64ArrayList, thisDefault Byte, thatDefault Float64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllAnyArrayList(l2 AnyArrayList, thisDefault Byte, thatDefault AnyArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllTuple2ArrayList(l2 Tuple2ArrayList, thisDefault Byte, thatDefault Tuple2Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllBoolOptionList(l2 BoolOptionList, thisDefault Byte, thatDefault BoolOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllStringOptionList(l2 StringOptionList, thisDefault Byte, thatDefault StringOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllIntOptionList(l2 IntOptionList, thisDefault Byte, thatDefault IntOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllInt64OptionList(l2 Int64OptionList, thisDefault Byte, thatDefault Int64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllByteOptionList(l2 ByteOptionList, thisDefault Byte, thatDefault ByteOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllRuneOptionList(l2 RuneOptionList, thisDefault Byte, thatDefault RuneOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllFloat32OptionList(l2 Float32OptionList, thisDefault Byte, thatDefault Float32Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllFloat64OptionList(l2 Float64OptionList, thisDefault Byte, thatDefault Float64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllAnyOptionList(l2 AnyOptionList, thisDefault Byte, thatDefault AnyOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllTuple2OptionList(l2 Tuple2OptionList, thisDefault Byte, thatDefault Tuple2Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllBoolListList(l2 BoolListList, thisDefault Byte, thatDefault BoolList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllStringListList(l2 StringListList, thisDefault Byte, thatDefault StringList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllIntListList(l2 IntListList, thisDefault Byte, thatDefault IntList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllInt64ListList(l2 Int64ListList, thisDefault Byte, thatDefault Int64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllByteListList(l2 ByteListList, thisDefault Byte, thatDefault ByteList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllRuneListList(l2 RuneListList, thisDefault Byte, thatDefault RuneList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllFloat32ListList(l2 Float32ListList, thisDefault Byte, thatDefault Float32List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllFloat64ListList(l2 Float64ListList, thisDefault Byte, thatDefault Float64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllAnyListList(l2 AnyListList, thisDefault Byte, thatDefault AnyList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllTuple2ListList(l2 Tuple2ListList, thisDefault Byte, thatDefault Tuple2List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllBoolArray(l2 BoolArray, thisDefault Byte, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllStringArray(l2 StringArray, thisDefault Byte, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllIntArray(l2 IntArray, thisDefault Byte, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllInt64Array(l2 Int64Array, thisDefault Byte, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllByteArray(l2 ByteArray, thisDefault Byte, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllRuneArray(l2 RuneArray, thisDefault Byte, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllFloat32Array(l2 Float32Array, thisDefault Byte, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllFloat64Array(l2 Float64Array, thisDefault Byte, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllAnyArray(l2 AnyArray, thisDefault Byte, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l ByteList) ZipAllTuple2Array(l2 Tuple2Array, thisDefault Byte, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllBoolList(l2 BoolList, thisDefault Rune, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllStringList(l2 StringList, thisDefault Rune, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllIntList(l2 IntList, thisDefault Rune, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllInt64List(l2 Int64List, thisDefault Rune, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllByteList(l2 ByteList, thisDefault Rune, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllRuneList(l2 RuneList, thisDefault Rune, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllFloat32List(l2 Float32List, thisDefault Rune, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllFloat64List(l2 Float64List, thisDefault Rune, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllAnyList(l2 AnyList, thisDefault Rune, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllTuple2List(l2 Tuple2List, thisDefault Rune, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllBoolArrayList(l2 BoolArrayList, thisDefault Rune, thatDefault BoolArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllStringArrayList(l2 StringArrayList, thisDefault Rune, thatDefault StringArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllIntArrayList(l2 IntArrayList, thisDefault Rune, thatDefault IntArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllInt64ArrayList(l2 Int64ArrayList, thisDefault Rune, thatDefault Int64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllByteArrayList(l2 ByteArrayList, thisDefault Rune, thatDefault ByteArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllRuneArrayList(l2 RuneArrayList, thisDefault Rune, thatDefault RuneArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllFloat32ArrayList(l2 Float32ArrayList, thisDefault Rune, thatDefault Float32Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllFloat64ArrayList(l2 Float64ArrayList, thisDefault Rune, thatDefault Float64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllAnyArrayList(l2 AnyArrayList, thisDefault Rune, thatDefault AnyArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllTuple2ArrayList(l2 Tuple2ArrayList, thisDefault Rune, thatDefault Tuple2Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllBoolOptionList(l2 BoolOptionList, thisDefault Rune, thatDefault BoolOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllStringOptionList(l2 StringOptionList, thisDefault Rune, thatDefault StringOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllIntOptionList(l2 IntOptionList, thisDefault Rune, thatDefault IntOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllInt64OptionList(l2 Int64OptionList, thisDefault Rune, thatDefault Int64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllByteOptionList(l2 ByteOptionList, thisDefault Rune, thatDefault ByteOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllRuneOptionList(l2 RuneOptionList, thisDefault Rune, thatDefault RuneOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllFloat32OptionList(l2 Float32OptionList, thisDefault Rune, thatDefault Float32Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllFloat64OptionList(l2 Float64OptionList, thisDefault Rune, thatDefault Float64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllAnyOptionList(l2 AnyOptionList, thisDefault Rune, thatDefault AnyOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllTuple2OptionList(l2 Tuple2OptionList, thisDefault Rune, thatDefault Tuple2Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllBoolListList(l2 BoolListList, thisDefault Rune, thatDefault BoolList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllStringListList(l2 StringListList, thisDefault Rune, thatDefault StringList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllIntListList(l2 IntListList, thisDefault Rune, thatDefault IntList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllInt64ListList(l2 Int64ListList, thisDefault Rune, thatDefault Int64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllByteListList(l2 ByteListList, thisDefault Rune, thatDefault ByteList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllRuneListList(l2 RuneListList, thisDefault Rune, thatDefault RuneList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllFloat32ListList(l2 Float32ListList, thisDefault Rune, thatDefault Float32List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllFloat64ListList(l2 Float64ListList, thisDefault Rune, thatDefault Float64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllAnyListList(l2 AnyListList, thisDefault Rune, thatDefault AnyList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllTuple2ListList(l2 Tuple2ListList, thisDefault Rune, thatDefault Tuple2List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllBoolArray(l2 BoolArray, thisDefault Rune, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllStringArray(l2 StringArray, thisDefault Rune, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllIntArray(l2 IntArray, thisDefault Rune, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllInt64Array(l2 Int64Array, thisDefault Rune, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllByteArray(l2 ByteArray, thisDefault Rune, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllRuneArray(l2 RuneArray, thisDefault Rune, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllFloat32Array(l2 Float32Array, thisDefault Rune, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllFloat64Array(l2 Float64Array, thisDefault Rune, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllAnyArray(l2 AnyArray, thisDefault Rune, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l RuneList) ZipAllTuple2Array(l2 Tuple2Array, thisDefault Rune, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllBoolList(l2 BoolList, thisDefault Float32, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllStringList(l2 StringList, thisDefault Float32, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllIntList(l2 IntList, thisDefault Float32, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllInt64List(l2 Int64List, thisDefault Float32, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllByteList(l2 ByteList, thisDefault Float32, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllRuneList(l2 RuneList, thisDefault Float32, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllFloat32List(l2 Float32List, thisDefault Float32, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllFloat64List(l2 Float64List, thisDefault Float32, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllAnyList(l2 AnyList, thisDefault Float32, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllTuple2List(l2 Tuple2List, thisDefault Float32, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllBoolArrayList(l2 BoolArrayList, thisDefault Float32, thatDefault BoolArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllStringArrayList(l2 StringArrayList, thisDefault Float32, thatDefault StringArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllIntArrayList(l2 IntArrayList, thisDefault Float32, thatDefault IntArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllInt64ArrayList(l2 Int64ArrayList, thisDefault Float32, thatDefault Int64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllByteArrayList(l2 ByteArrayList, thisDefault Float32, thatDefault ByteArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllRuneArrayList(l2 RuneArrayList, thisDefault Float32, thatDefault RuneArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllFloat32ArrayList(l2 Float32ArrayList, thisDefault Float32, thatDefault Float32Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllFloat64ArrayList(l2 Float64ArrayList, thisDefault Float32, thatDefault Float64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllAnyArrayList(l2 AnyArrayList, thisDefault Float32, thatDefault AnyArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllTuple2ArrayList(l2 Tuple2ArrayList, thisDefault Float32, thatDefault Tuple2Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllBoolOptionList(l2 BoolOptionList, thisDefault Float32, thatDefault BoolOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllStringOptionList(l2 StringOptionList, thisDefault Float32, thatDefault StringOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllIntOptionList(l2 IntOptionList, thisDefault Float32, thatDefault IntOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllInt64OptionList(l2 Int64OptionList, thisDefault Float32, thatDefault Int64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllByteOptionList(l2 ByteOptionList, thisDefault Float32, thatDefault ByteOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllRuneOptionList(l2 RuneOptionList, thisDefault Float32, thatDefault RuneOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllFloat32OptionList(l2 Float32OptionList, thisDefault Float32, thatDefault Float32Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllFloat64OptionList(l2 Float64OptionList, thisDefault Float32, thatDefault Float64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllAnyOptionList(l2 AnyOptionList, thisDefault Float32, thatDefault AnyOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllTuple2OptionList(l2 Tuple2OptionList, thisDefault Float32, thatDefault Tuple2Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllBoolListList(l2 BoolListList, thisDefault Float32, thatDefault BoolList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllStringListList(l2 StringListList, thisDefault Float32, thatDefault StringList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllIntListList(l2 IntListList, thisDefault Float32, thatDefault IntList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllInt64ListList(l2 Int64ListList, thisDefault Float32, thatDefault Int64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllByteListList(l2 ByteListList, thisDefault Float32, thatDefault ByteList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllRuneListList(l2 RuneListList, thisDefault Float32, thatDefault RuneList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllFloat32ListList(l2 Float32ListList, thisDefault Float32, thatDefault Float32List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllFloat64ListList(l2 Float64ListList, thisDefault Float32, thatDefault Float64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllAnyListList(l2 AnyListList, thisDefault Float32, thatDefault AnyList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllTuple2ListList(l2 Tuple2ListList, thisDefault Float32, thatDefault Tuple2List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllBoolArray(l2 BoolArray, thisDefault Float32, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllStringArray(l2 StringArray, thisDefault Float32, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllIntArray(l2 IntArray, thisDefault Float32, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllInt64Array(l2 Int64Array, thisDefault Float32, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllByteArray(l2 ByteArray, thisDefault Float32, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllRuneArray(l2 RuneArray, thisDefault Float32, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllFloat32Array(l2 Float32Array, thisDefault Float32, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllFloat64Array(l2 Float64Array, thisDefault Float32, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllAnyArray(l2 AnyArray, thisDefault Float32, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float32List) ZipAllTuple2Array(l2 Tuple2Array, thisDefault Float32, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllBoolList(l2 BoolList, thisDefault Float64, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllStringList(l2 StringList, thisDefault Float64, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllIntList(l2 IntList, thisDefault Float64, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllInt64List(l2 Int64List, thisDefault Float64, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllByteList(l2 ByteList, thisDefault Float64, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllRuneList(l2 RuneList, thisDefault Float64, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllFloat32List(l2 Float32List, thisDefault Float64, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllFloat64List(l2 Float64List, thisDefault Float64, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllAnyList(l2 AnyList, thisDefault Float64, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllTuple2List(l2 Tuple2List, thisDefault Float64, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllBoolArrayList(l2 BoolArrayList, thisDefault Float64, thatDefault BoolArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllStringArrayList(l2 StringArrayList, thisDefault Float64, thatDefault StringArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllIntArrayList(l2 IntArrayList, thisDefault Float64, thatDefault IntArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllInt64ArrayList(l2 Int64ArrayList, thisDefault Float64, thatDefault Int64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllByteArrayList(l2 ByteArrayList, thisDefault Float64, thatDefault ByteArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllRuneArrayList(l2 RuneArrayList, thisDefault Float64, thatDefault RuneArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllFloat32ArrayList(l2 Float32ArrayList, thisDefault Float64, thatDefault Float32Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllFloat64ArrayList(l2 Float64ArrayList, thisDefault Float64, thatDefault Float64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllAnyArrayList(l2 AnyArrayList, thisDefault Float64, thatDefault AnyArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllTuple2ArrayList(l2 Tuple2ArrayList, thisDefault Float64, thatDefault Tuple2Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllBoolOptionList(l2 BoolOptionList, thisDefault Float64, thatDefault BoolOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllStringOptionList(l2 StringOptionList, thisDefault Float64, thatDefault StringOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllIntOptionList(l2 IntOptionList, thisDefault Float64, thatDefault IntOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllInt64OptionList(l2 Int64OptionList, thisDefault Float64, thatDefault Int64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllByteOptionList(l2 ByteOptionList, thisDefault Float64, thatDefault ByteOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllRuneOptionList(l2 RuneOptionList, thisDefault Float64, thatDefault RuneOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllFloat32OptionList(l2 Float32OptionList, thisDefault Float64, thatDefault Float32Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllFloat64OptionList(l2 Float64OptionList, thisDefault Float64, thatDefault Float64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllAnyOptionList(l2 AnyOptionList, thisDefault Float64, thatDefault AnyOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllTuple2OptionList(l2 Tuple2OptionList, thisDefault Float64, thatDefault Tuple2Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllBoolListList(l2 BoolListList, thisDefault Float64, thatDefault BoolList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllStringListList(l2 StringListList, thisDefault Float64, thatDefault StringList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllIntListList(l2 IntListList, thisDefault Float64, thatDefault IntList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllInt64ListList(l2 Int64ListList, thisDefault Float64, thatDefault Int64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllByteListList(l2 ByteListList, thisDefault Float64, thatDefault ByteList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllRuneListList(l2 RuneListList, thisDefault Float64, thatDefault RuneList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllFloat32ListList(l2 Float32ListList, thisDefault Float64, thatDefault Float32List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllFloat64ListList(l2 Float64ListList, thisDefault Float64, thatDefault Float64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllAnyListList(l2 AnyListList, thisDefault Float64, thatDefault AnyList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllTuple2ListList(l2 Tuple2ListList, thisDefault Float64, thatDefault Tuple2List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllBoolArray(l2 BoolArray, thisDefault Float64, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllStringArray(l2 StringArray, thisDefault Float64, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllIntArray(l2 IntArray, thisDefault Float64, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllInt64Array(l2 Int64Array, thisDefault Float64, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllByteArray(l2 ByteArray, thisDefault Float64, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllRuneArray(l2 RuneArray, thisDefault Float64, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllFloat32Array(l2 Float32Array, thisDefault Float64, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllFloat64Array(l2 Float64Array, thisDefault Float64, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllAnyArray(l2 AnyArray, thisDefault Float64, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Float64List) ZipAllTuple2Array(l2 Tuple2Array, thisDefault Float64, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllBoolList(l2 BoolList, thisDefault Any, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllStringList(l2 StringList, thisDefault Any, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllIntList(l2 IntList, thisDefault Any, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllInt64List(l2 Int64List, thisDefault Any, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllByteList(l2 ByteList, thisDefault Any, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllRuneList(l2 RuneList, thisDefault Any, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllFloat32List(l2 Float32List, thisDefault Any, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllFloat64List(l2 Float64List, thisDefault Any, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllAnyList(l2 AnyList, thisDefault Any, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllTuple2List(l2 Tuple2List, thisDefault Any, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllBoolArrayList(l2 BoolArrayList, thisDefault Any, thatDefault BoolArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllStringArrayList(l2 StringArrayList, thisDefault Any, thatDefault StringArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllIntArrayList(l2 IntArrayList, thisDefault Any, thatDefault IntArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllInt64ArrayList(l2 Int64ArrayList, thisDefault Any, thatDefault Int64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllByteArrayList(l2 ByteArrayList, thisDefault Any, thatDefault ByteArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllRuneArrayList(l2 RuneArrayList, thisDefault Any, thatDefault RuneArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllFloat32ArrayList(l2 Float32ArrayList, thisDefault Any, thatDefault Float32Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllFloat64ArrayList(l2 Float64ArrayList, thisDefault Any, thatDefault Float64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllAnyArrayList(l2 AnyArrayList, thisDefault Any, thatDefault AnyArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllTuple2ArrayList(l2 Tuple2ArrayList, thisDefault Any, thatDefault Tuple2Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllBoolOptionList(l2 BoolOptionList, thisDefault Any, thatDefault BoolOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllStringOptionList(l2 StringOptionList, thisDefault Any, thatDefault StringOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllIntOptionList(l2 IntOptionList, thisDefault Any, thatDefault IntOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllInt64OptionList(l2 Int64OptionList, thisDefault Any, thatDefault Int64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllByteOptionList(l2 ByteOptionList, thisDefault Any, thatDefault ByteOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllRuneOptionList(l2 RuneOptionList, thisDefault Any, thatDefault RuneOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllFloat32OptionList(l2 Float32OptionList, thisDefault Any, thatDefault Float32Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllFloat64OptionList(l2 Float64OptionList, thisDefault Any, thatDefault Float64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllAnyOptionList(l2 AnyOptionList, thisDefault Any, thatDefault AnyOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllTuple2OptionList(l2 Tuple2OptionList, thisDefault Any, thatDefault Tuple2Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllBoolListList(l2 BoolListList, thisDefault Any, thatDefault BoolList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllStringListList(l2 StringListList, thisDefault Any, thatDefault StringList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllIntListList(l2 IntListList, thisDefault Any, thatDefault IntList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllInt64ListList(l2 Int64ListList, thisDefault Any, thatDefault Int64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllByteListList(l2 ByteListList, thisDefault Any, thatDefault ByteList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllRuneListList(l2 RuneListList, thisDefault Any, thatDefault RuneList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllFloat32ListList(l2 Float32ListList, thisDefault Any, thatDefault Float32List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllFloat64ListList(l2 Float64ListList, thisDefault Any, thatDefault Float64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllAnyListList(l2 AnyListList, thisDefault Any, thatDefault AnyList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllTuple2ListList(l2 Tuple2ListList, thisDefault Any, thatDefault Tuple2List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllBoolArray(l2 BoolArray, thisDefault Any, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllStringArray(l2 StringArray, thisDefault Any, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllIntArray(l2 IntArray, thisDefault Any, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllInt64Array(l2 Int64Array, thisDefault Any, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllByteArray(l2 ByteArray, thisDefault Any, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllRuneArray(l2 RuneArray, thisDefault Any, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllFloat32Array(l2 Float32Array, thisDefault Any, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllFloat64Array(l2 Float64Array, thisDefault Any, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllAnyArray(l2 AnyArray, thisDefault Any, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l AnyList) ZipAllTuple2Array(l2 Tuple2Array, thisDefault Any, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllBoolList(l2 BoolList, thisDefault Tuple2, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllStringList(l2 StringList, thisDefault Tuple2, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllIntList(l2 IntList, thisDefault Tuple2, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllInt64List(l2 Int64List, thisDefault Tuple2, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllByteList(l2 ByteList, thisDefault Tuple2, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllRuneList(l2 RuneList, thisDefault Tuple2, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllFloat32List(l2 Float32List, thisDefault Tuple2, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllFloat64List(l2 Float64List, thisDefault Tuple2, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllAnyList(l2 AnyList, thisDefault Tuple2, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllTuple2List(l2 Tuple2List, thisDefault Tuple2, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllBoolArrayList(l2 BoolArrayList, thisDefault Tuple2, thatDefault BoolArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllStringArrayList(l2 StringArrayList, thisDefault Tuple2, thatDefault StringArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllIntArrayList(l2 IntArrayList, thisDefault Tuple2, thatDefault IntArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllInt64ArrayList(l2 Int64ArrayList, thisDefault Tuple2, thatDefault Int64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllByteArrayList(l2 ByteArrayList, thisDefault Tuple2, thatDefault ByteArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllRuneArrayList(l2 RuneArrayList, thisDefault Tuple2, thatDefault RuneArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllFloat32ArrayList(l2 Float32ArrayList, thisDefault Tuple2, thatDefault Float32Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllFloat64ArrayList(l2 Float64ArrayList, thisDefault Tuple2, thatDefault Float64Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllAnyArrayList(l2 AnyArrayList, thisDefault Tuple2, thatDefault AnyArray) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllTuple2ArrayList(l2 Tuple2ArrayList, thisDefault Tuple2, thatDefault Tuple2Array) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllBoolOptionList(l2 BoolOptionList, thisDefault Tuple2, thatDefault BoolOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllStringOptionList(l2 StringOptionList, thisDefault Tuple2, thatDefault StringOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllIntOptionList(l2 IntOptionList, thisDefault Tuple2, thatDefault IntOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllInt64OptionList(l2 Int64OptionList, thisDefault Tuple2, thatDefault Int64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllByteOptionList(l2 ByteOptionList, thisDefault Tuple2, thatDefault ByteOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllRuneOptionList(l2 RuneOptionList, thisDefault Tuple2, thatDefault RuneOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllFloat32OptionList(l2 Float32OptionList, thisDefault Tuple2, thatDefault Float32Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllFloat64OptionList(l2 Float64OptionList, thisDefault Tuple2, thatDefault Float64Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllAnyOptionList(l2 AnyOptionList, thisDefault Tuple2, thatDefault AnyOption) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllTuple2OptionList(l2 Tuple2OptionList, thisDefault Tuple2, thatDefault Tuple2Option) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllBoolListList(l2 BoolListList, thisDefault Tuple2, thatDefault BoolList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllStringListList(l2 StringListList, thisDefault Tuple2, thatDefault StringList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllIntListList(l2 IntListList, thisDefault Tuple2, thatDefault IntList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllInt64ListList(l2 Int64ListList, thisDefault Tuple2, thatDefault Int64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllByteListList(l2 ByteListList, thisDefault Tuple2, thatDefault ByteList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllRuneListList(l2 RuneListList, thisDefault Tuple2, thatDefault RuneList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllFloat32ListList(l2 Float32ListList, thisDefault Tuple2, thatDefault Float32List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllFloat64ListList(l2 Float64ListList, thisDefault Tuple2, thatDefault Float64List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllAnyListList(l2 AnyListList, thisDefault Tuple2, thatDefault AnyList) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllTuple2ListList(l2 Tuple2ListList, thisDefault Tuple2, thatDefault Tuple2List) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	xs2 := l2
	maxLen := int(Int(l.Size()).Max(Int(l2.Size())))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if xs2.NonEmpty() {
			e2 = *xs2.head
			xs2 = *xs2.tail
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllBoolArray(l2 BoolArray, thisDefault Tuple2, thatDefault Bool) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllStringArray(l2 StringArray, thisDefault Tuple2, thatDefault String) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllIntArray(l2 IntArray, thisDefault Tuple2, thatDefault Int) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllInt64Array(l2 Int64Array, thisDefault Tuple2, thatDefault Int64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllByteArray(l2 ByteArray, thisDefault Tuple2, thatDefault Byte) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllRuneArray(l2 RuneArray, thisDefault Tuple2, thatDefault Rune) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllFloat32Array(l2 Float32Array, thisDefault Tuple2, thatDefault Float32) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllFloat64Array(l2 Float64Array, thisDefault Tuple2, thatDefault Float64) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllAnyArray(l2 AnyArray, thisDefault Tuple2, thatDefault Any) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipAllTuple2Array(l2 Tuple2Array, thisDefault Tuple2, thatDefault Tuple2) Tuple2List {
	zipped := NilTuple2
	xs1 := l
	len1 := l.Size()
	len2 := len(l2)
	maxLen := int(Int(len1).Max(Int(len2)))

	var e1, e2 Any
	for i := 0; i < maxLen; i++ {
		if xs1.NonEmpty() {
			e1 = *xs1.head
			xs1 = *xs1.tail
		} else {
			e1 = thisDefault
		}
		if i < len2 {
			e2 = l2[i]
		} else {
			e2 = thatDefault
		}

		zipped = zipped.Cons(Tuple2{e1, e2})
	}
	return zipped.Reverse()
}
