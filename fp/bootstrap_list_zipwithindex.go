// bootstrap_list_zipwithindex.go
// DO NOT EDIT THIS FILE WAS GENERATED AUTOMATICALLY BY https://github.com/zx80live/gofp-bootstrap

package fp

func (l BoolList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l StringList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l IntList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Int64List) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l ByteList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l RuneList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Float32List) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Float64List) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l AnyList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Tuple2List) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l BoolArrayList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l StringArrayList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l IntArrayList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Int64ArrayList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l ByteArrayList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l RuneArrayList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Float32ArrayList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Float64ArrayList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l AnyArrayList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Tuple2ArrayList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l BoolOptionList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l StringOptionList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l IntOptionList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Int64OptionList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l ByteOptionList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l RuneOptionList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Float32OptionList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Float64OptionList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l AnyOptionList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Tuple2OptionList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l BoolListList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l StringListList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l IntListList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Int64ListList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l ByteListList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l RuneListList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Float32ListList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Float64ListList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l AnyListList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
func (l Tuple2ListList) ZipWithIndex() Tuple2List {
	zipped := NilTuple2
	xs := l
	for i := 0; xs.NonEmpty(); i++ {
		zipped = zipped.Cons(Tuple2{*xs.head, i})
		xs = *xs.tail
	}
	return zipped.Reverse()
}
