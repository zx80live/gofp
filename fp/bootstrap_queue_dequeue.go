// bootstrap_queue_dequeue.go
// DO NOT EDIT THIS FILE WAS GENERATED AUTOMATICALLY BY https://github.com/zx80live/gofp-bootstrap

package fp

func (q BoolQueue) Dequeue() (bool, BoolQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, BoolQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q StringQueue) Dequeue() (string, StringQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, StringQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q IntQueue) Dequeue() (int, IntQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, IntQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Int64Queue) Dequeue() (int64, Int64Queue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Int64Queue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q ByteQueue) Dequeue() (byte, ByteQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, ByteQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q RuneQueue) Dequeue() (rune, RuneQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, RuneQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Float32Queue) Dequeue() (float32, Float32Queue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Float32Queue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Float64Queue) Dequeue() (float64, Float64Queue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Float64Queue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q AnyQueue) Dequeue() (Any, AnyQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, AnyQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Tuple2Queue) Dequeue() (Tuple2, Tuple2Queue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Tuple2Queue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q BoolArrayQueue) Dequeue() ([]bool, BoolArrayQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, BoolArrayQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q StringArrayQueue) Dequeue() ([]string, StringArrayQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, StringArrayQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q IntArrayQueue) Dequeue() ([]int, IntArrayQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, IntArrayQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Int64ArrayQueue) Dequeue() ([]int64, Int64ArrayQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Int64ArrayQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q ByteArrayQueue) Dequeue() ([]byte, ByteArrayQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, ByteArrayQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q RuneArrayQueue) Dequeue() ([]rune, RuneArrayQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, RuneArrayQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Float32ArrayQueue) Dequeue() ([]float32, Float32ArrayQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Float32ArrayQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Float64ArrayQueue) Dequeue() ([]float64, Float64ArrayQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Float64ArrayQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q AnyArrayQueue) Dequeue() ([]Any, AnyArrayQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, AnyArrayQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Tuple2ArrayQueue) Dequeue() ([]Tuple2, Tuple2ArrayQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Tuple2ArrayQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q BoolOptionQueue) Dequeue() (BoolOption, BoolOptionQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, BoolOptionQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q StringOptionQueue) Dequeue() (StringOption, StringOptionQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, StringOptionQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q IntOptionQueue) Dequeue() (IntOption, IntOptionQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, IntOptionQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Int64OptionQueue) Dequeue() (Int64Option, Int64OptionQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Int64OptionQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q ByteOptionQueue) Dequeue() (ByteOption, ByteOptionQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, ByteOptionQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q RuneOptionQueue) Dequeue() (RuneOption, RuneOptionQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, RuneOptionQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Float32OptionQueue) Dequeue() (Float32Option, Float32OptionQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Float32OptionQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Float64OptionQueue) Dequeue() (Float64Option, Float64OptionQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Float64OptionQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q AnyOptionQueue) Dequeue() (AnyOption, AnyOptionQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, AnyOptionQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Tuple2OptionQueue) Dequeue() (Tuple2Option, Tuple2OptionQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Tuple2OptionQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q BoolListQueue) Dequeue() (BoolList, BoolListQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, BoolListQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q StringListQueue) Dequeue() (StringList, StringListQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, StringListQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q IntListQueue) Dequeue() (IntList, IntListQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, IntListQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Int64ListQueue) Dequeue() (Int64List, Int64ListQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Int64ListQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q ByteListQueue) Dequeue() (ByteList, ByteListQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, ByteListQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q RuneListQueue) Dequeue() (RuneList, RuneListQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, RuneListQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Float32ListQueue) Dequeue() (Float32List, Float32ListQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Float32ListQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Float64ListQueue) Dequeue() (Float64List, Float64ListQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Float64ListQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q AnyListQueue) Dequeue() (AnyList, AnyListQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, AnyListQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
func (q Tuple2ListQueue) Dequeue() (Tuple2List, Tuple2ListQueue) {
	if q.NonEmpty() {
		swapped := q.swap()
		h := (*swapped.out).Head()
		t := (*swapped.out).Tail()
		return h, Tuple2ListQueue{swapped.in, &t}
	} else {
		panic("can't dequeue from empty queue ")
	}
}
