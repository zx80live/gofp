// bootstrap_queue_find.go
// DO NOT EDIT THIS FILE WAS GENERATED AUTOMATICALLY BY https://github.com/zx80live/gofp-bootstrap

package fp

func (q BoolQueue) Find(p func(bool) bool) BoolOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkBoolOption(h)
		}
		xs = t
	}
	return NoneBool
}
func (q StringQueue) Find(p func(string) bool) StringOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkStringOption(h)
		}
		xs = t
	}
	return NoneString
}
func (q IntQueue) Find(p func(int) bool) IntOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkIntOption(h)
		}
		xs = t
	}
	return NoneInt
}
func (q Int64Queue) Find(p func(int64) bool) Int64Option {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkInt64Option(h)
		}
		xs = t
	}
	return NoneInt64
}
func (q ByteQueue) Find(p func(byte) bool) ByteOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkByteOption(h)
		}
		xs = t
	}
	return NoneByte
}
func (q RuneQueue) Find(p func(rune) bool) RuneOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkRuneOption(h)
		}
		xs = t
	}
	return NoneRune
}
func (q Float32Queue) Find(p func(float32) bool) Float32Option {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkFloat32Option(h)
		}
		xs = t
	}
	return NoneFloat32
}
func (q Float64Queue) Find(p func(float64) bool) Float64Option {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkFloat64Option(h)
		}
		xs = t
	}
	return NoneFloat64
}
func (q AnyQueue) Find(p func(Any) bool) AnyOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkAnyOption(h)
		}
		xs = t
	}
	return NoneAny
}
func (q Tuple2Queue) Find(p func(Tuple2) bool) Tuple2Option {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkTuple2Option(h)
		}
		xs = t
	}
	return NoneTuple2
}
func (q BoolArrayQueue) Find(p func([]bool) bool) BoolArrayOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkBoolArrayOption(h)
		}
		xs = t
	}
	return NoneBoolArray
}
func (q StringArrayQueue) Find(p func([]string) bool) StringArrayOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkStringArrayOption(h)
		}
		xs = t
	}
	return NoneStringArray
}
func (q IntArrayQueue) Find(p func([]int) bool) IntArrayOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkIntArrayOption(h)
		}
		xs = t
	}
	return NoneIntArray
}
func (q Int64ArrayQueue) Find(p func([]int64) bool) Int64ArrayOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkInt64ArrayOption(h)
		}
		xs = t
	}
	return NoneInt64Array
}
func (q ByteArrayQueue) Find(p func([]byte) bool) ByteArrayOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkByteArrayOption(h)
		}
		xs = t
	}
	return NoneByteArray
}
func (q RuneArrayQueue) Find(p func([]rune) bool) RuneArrayOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkRuneArrayOption(h)
		}
		xs = t
	}
	return NoneRuneArray
}
func (q Float32ArrayQueue) Find(p func([]float32) bool) Float32ArrayOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkFloat32ArrayOption(h)
		}
		xs = t
	}
	return NoneFloat32Array
}
func (q Float64ArrayQueue) Find(p func([]float64) bool) Float64ArrayOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkFloat64ArrayOption(h)
		}
		xs = t
	}
	return NoneFloat64Array
}
func (q AnyArrayQueue) Find(p func([]Any) bool) AnyArrayOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkAnyArrayOption(h)
		}
		xs = t
	}
	return NoneAnyArray
}
func (q Tuple2ArrayQueue) Find(p func([]Tuple2) bool) Tuple2ArrayOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkTuple2ArrayOption(h)
		}
		xs = t
	}
	return NoneTuple2Array
}
func (q BoolOptionQueue) Find(p func(BoolOption) bool) BoolOptionOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkBoolOptionOption(h)
		}
		xs = t
	}
	return NoneBoolOption
}
func (q StringOptionQueue) Find(p func(StringOption) bool) StringOptionOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkStringOptionOption(h)
		}
		xs = t
	}
	return NoneStringOption
}
func (q IntOptionQueue) Find(p func(IntOption) bool) IntOptionOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkIntOptionOption(h)
		}
		xs = t
	}
	return NoneIntOption
}
func (q Int64OptionQueue) Find(p func(Int64Option) bool) Int64OptionOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkInt64OptionOption(h)
		}
		xs = t
	}
	return NoneInt64Option
}
func (q ByteOptionQueue) Find(p func(ByteOption) bool) ByteOptionOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkByteOptionOption(h)
		}
		xs = t
	}
	return NoneByteOption
}
func (q RuneOptionQueue) Find(p func(RuneOption) bool) RuneOptionOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkRuneOptionOption(h)
		}
		xs = t
	}
	return NoneRuneOption
}
func (q Float32OptionQueue) Find(p func(Float32Option) bool) Float32OptionOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkFloat32OptionOption(h)
		}
		xs = t
	}
	return NoneFloat32Option
}
func (q Float64OptionQueue) Find(p func(Float64Option) bool) Float64OptionOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkFloat64OptionOption(h)
		}
		xs = t
	}
	return NoneFloat64Option
}
func (q AnyOptionQueue) Find(p func(AnyOption) bool) AnyOptionOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkAnyOptionOption(h)
		}
		xs = t
	}
	return NoneAnyOption
}
func (q Tuple2OptionQueue) Find(p func(Tuple2Option) bool) Tuple2OptionOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkTuple2OptionOption(h)
		}
		xs = t
	}
	return NoneTuple2Option
}
func (q BoolListQueue) Find(p func(BoolList) bool) BoolListOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkBoolListOption(h)
		}
		xs = t
	}
	return NoneBoolList
}
func (q StringListQueue) Find(p func(StringList) bool) StringListOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkStringListOption(h)
		}
		xs = t
	}
	return NoneStringList
}
func (q IntListQueue) Find(p func(IntList) bool) IntListOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkIntListOption(h)
		}
		xs = t
	}
	return NoneIntList
}
func (q Int64ListQueue) Find(p func(Int64List) bool) Int64ListOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkInt64ListOption(h)
		}
		xs = t
	}
	return NoneInt64List
}
func (q ByteListQueue) Find(p func(ByteList) bool) ByteListOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkByteListOption(h)
		}
		xs = t
	}
	return NoneByteList
}
func (q RuneListQueue) Find(p func(RuneList) bool) RuneListOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkRuneListOption(h)
		}
		xs = t
	}
	return NoneRuneList
}
func (q Float32ListQueue) Find(p func(Float32List) bool) Float32ListOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkFloat32ListOption(h)
		}
		xs = t
	}
	return NoneFloat32List
}
func (q Float64ListQueue) Find(p func(Float64List) bool) Float64ListOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkFloat64ListOption(h)
		}
		xs = t
	}
	return NoneFloat64List
}
func (q AnyListQueue) Find(p func(AnyList) bool) AnyListOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkAnyListOption(h)
		}
		xs = t
	}
	return NoneAnyList
}
func (q Tuple2ListQueue) Find(p func(Tuple2List) bool) Tuple2ListOption {
	xs := q
	for xs.NonEmpty() {
		h, t := xs.Dequeue()
		if p(h) {
			return MkTuple2ListOption(h)
		}
		xs = t
	}
	return NoneTuple2List
}
