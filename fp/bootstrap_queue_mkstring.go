// bootstrap_queue_mkstring.go
// DO NOT EDIT THIS FILE WAS GENERATED AUTOMATICALLY BY https://github.com/zx80live/gofp-bootstrap

package fp

import "fmt"

func (q BoolQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, BoolToString(Bool(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q StringQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, StringToString(String(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q IntQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, IntToString(Int(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Int64Queue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Int64ToString(Int64(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q ByteQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, ByteToString(Byte(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q RuneQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, RuneToString(Rune(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Float32Queue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Float32ToString(Float32(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Float64Queue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Float64ToString(Float64(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q AnyQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, AnyToString(Any(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Tuple2Queue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Tuple2ToString(Tuple2(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q BoolArrayQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, BoolArrayToString(BoolArray(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q StringArrayQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, StringArrayToString(StringArray(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q IntArrayQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, IntArrayToString(IntArray(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Int64ArrayQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Int64ArrayToString(Int64Array(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q ByteArrayQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, ByteArrayToString(ByteArray(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q RuneArrayQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, RuneArrayToString(RuneArray(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Float32ArrayQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Float32ArrayToString(Float32Array(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Float64ArrayQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Float64ArrayToString(Float64Array(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q AnyArrayQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, AnyArrayToString(AnyArray(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Tuple2ArrayQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Tuple2ArrayToString(Tuple2Array(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q BoolOptionQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, BoolOptionToString(BoolOption(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q StringOptionQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, StringOptionToString(StringOption(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q IntOptionQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, IntOptionToString(IntOption(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Int64OptionQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Int64OptionToString(Int64Option(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q ByteOptionQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, ByteOptionToString(ByteOption(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q RuneOptionQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, RuneOptionToString(RuneOption(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Float32OptionQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Float32OptionToString(Float32Option(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Float64OptionQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Float64OptionToString(Float64Option(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q AnyOptionQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, AnyOptionToString(AnyOption(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Tuple2OptionQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Tuple2OptionToString(Tuple2Option(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q BoolListQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, BoolListToString(BoolList(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q StringListQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, StringListToString(StringList(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q IntListQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, IntListToString(IntList(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Int64ListQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Int64ListToString(Int64List(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q ByteListQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, ByteListToString(ByteList(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q RuneListQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, RuneListToString(RuneList(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Float32ListQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Float32ListToString(Float32List(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Float64ListQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Float64ListToString(Float64List(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q AnyListQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, AnyListToString(AnyList(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
func (q Tuple2ListQueue) MkString(start, sep, end string) String {
	if q.IsEmpty() {
		return String(fmt.Sprintf("Queue()"))
	}
	content := ""
	xs := q
	for {
		h, t := xs.Dequeue()
		content = fmt.Sprintf("%v%v%v", content, Tuple2ListToString(Tuple2List(h)), sep)
		if t.IsEmpty() {
			break
		}
		xs = t
	}
	s := len(content)
	if s > 0 {
		content = content[:s-1]
	}
	return String(fmt.Sprintf("%v%v%v", start, content, end))
}
