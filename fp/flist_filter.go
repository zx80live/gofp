// flist_filter.go
// DO NOT EDIT THIS FILE WAS GENERATED AUTOMATICALLY BY gofp-bootstrap

package fp

func (l ListBool) Filter(p PredicateBool) ListBool {
	acc := NilBool
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListRune) Filter(p PredicateRune) ListRune {
	acc := NilRune
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListByte) Filter(p PredicateByte) ListByte {
	acc := NilByte
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInt) Filter(p PredicateInt) ListInt {
	acc := NilInt
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInt8) Filter(p PredicateInt8) ListInt8 {
	acc := NilInt8
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInt16) Filter(p PredicateInt16) ListInt16 {
	acc := NilInt16
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInt32) Filter(p PredicateInt32) ListInt32 {
	acc := NilInt32
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInt64) Filter(p PredicateInt64) ListInt64 {
	acc := NilInt64
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUint) Filter(p PredicateUint) ListUint {
	acc := NilUint
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUint8) Filter(p PredicateUint8) ListUint8 {
	acc := NilUint8
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUint16) Filter(p PredicateUint16) ListUint16 {
	acc := NilUint16
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUint32) Filter(p PredicateUint32) ListUint32 {
	acc := NilUint32
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUint64) Filter(p PredicateUint64) ListUint64 {
	acc := NilUint64
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUintptr) Filter(p PredicateUintptr) ListUintptr {
	acc := NilUintptr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListFloat32) Filter(p PredicateFloat32) ListFloat32 {
	acc := NilFloat32
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListFloat64) Filter(p PredicateFloat64) ListFloat64 {
	acc := NilFloat64
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListComplex64) Filter(p PredicateComplex64) ListComplex64 {
	acc := NilComplex64
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListComplex128) Filter(p PredicateComplex128) ListComplex128 {
	acc := NilComplex128
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListString) Filter(p PredicateString) ListString {
	acc := NilString
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInterface) Filter(p PredicateInterface) ListInterface {
	acc := NilInterface
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListBoolArr) Filter(p PredicateBoolArr) ListBoolArr {
	acc := NilBoolArr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListRuneArr) Filter(p PredicateRuneArr) ListRuneArr {
	acc := NilRuneArr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListByteArr) Filter(p PredicateByteArr) ListByteArr {
	acc := NilByteArr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListIntArr) Filter(p PredicateIntArr) ListIntArr {
	acc := NilIntArr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInt8Arr) Filter(p PredicateInt8Arr) ListInt8Arr {
	acc := NilInt8Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInt16Arr) Filter(p PredicateInt16Arr) ListInt16Arr {
	acc := NilInt16Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInt32Arr) Filter(p PredicateInt32Arr) ListInt32Arr {
	acc := NilInt32Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInt64Arr) Filter(p PredicateInt64Arr) ListInt64Arr {
	acc := NilInt64Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUintArr) Filter(p PredicateUintArr) ListUintArr {
	acc := NilUintArr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUint8Arr) Filter(p PredicateUint8Arr) ListUint8Arr {
	acc := NilUint8Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUint16Arr) Filter(p PredicateUint16Arr) ListUint16Arr {
	acc := NilUint16Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUint32Arr) Filter(p PredicateUint32Arr) ListUint32Arr {
	acc := NilUint32Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUint64Arr) Filter(p PredicateUint64Arr) ListUint64Arr {
	acc := NilUint64Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListUintptrArr) Filter(p PredicateUintptrArr) ListUintptrArr {
	acc := NilUintptrArr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListFloat32Arr) Filter(p PredicateFloat32Arr) ListFloat32Arr {
	acc := NilFloat32Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListFloat64Arr) Filter(p PredicateFloat64Arr) ListFloat64Arr {
	acc := NilFloat64Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListComplex64Arr) Filter(p PredicateComplex64Arr) ListComplex64Arr {
	acc := NilComplex64Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListComplex128Arr) Filter(p PredicateComplex128Arr) ListComplex128Arr {
	acc := NilComplex128Arr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListStringArr) Filter(p PredicateStringArr) ListStringArr {
	acc := NilStringArr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
func (l ListInterfaceArr) Filter(p PredicateInterfaceArr) ListInterfaceArr {
	acc := NilInterfaceArr
	xs := &l
	for xs.IsNotEmpty() {
		if p(*xs.head) {
			acc = acc.Cons(*xs.head)
		}
		xs = xs.tail
	}
	return acc.Reverse()
}
